%%%%%%%%%%%%%%%%%%%%

% Project Name: Semester Project Fall 2024 for EPFL
% File: main.tex
% Author: Keng-Yu Chen

%%%%%%%%%%%%%%%%%%%%

\input{header.tex}


\begin{document}

%% Title
\title{\textbf{The Cryptographic Layer of Biometric Authentication}}
\author{Keng-Yu Chen \\
  \multicolumn{1}{p{.7\textwidth}}{} \\
  \multicolumn{1}{p{.7\textwidth}}{\centering \textbf{Supervisor}: Serge Vaudenay}\\
  \multicolumn{1}{p{.7\textwidth}}{\centering LASEC, EPFL}\\
  \\
}
\date{\today}

\maketitle

%-------------------

%% Header and Foot
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{LASEC}
\fancyhead[R]{Keng-Yu Chen}
\fancyfoot[C]{\thepage}

%-------------------
% Abstract
\input{Contents/abstract}

%-------------------
% Introduction
\section{Introduction}
\label{sec:introdiction}
\input{Contents/introduction.tex}

%-------------------
% Fomalization
\section{Formalization}
\label{sec:formalization}
\input{Contents/formalization.tex}

%-------------------
% Security Games
\section{Security Games}
\label{sec:security_game}
\input{Contents/security_game.tex}

%-------------------
% Security Analysis: fh-IPFE-based Instantiation
\section{Security Analysis: fh-IPFE-based Instantiation}
\label{sec:security_analysis:fh-IPFE}
\input{Contents/security_analysis_fh-IPFE.tex}

%-------------------
% Security Analysis: Relational Hash-based Instantiation
\section{Security Analysis: Relational Hash-based Instantiation}
\label{sec:security_analysis:rh}
\input{Contents/security_analysis_rh.tex}

%-------------------

\newpage
\appendix

%-------------------

\section{Construction in \cite{cryptoeprint:2016/440}}
\label{sec:fh-IPFE-construction}

Let $\mathbb{G}_1$ and $\mathbb{G}_2$ be two groups of order a prime number $q$ with generators $g_1$ and $g_2$, respectively. Let $e: \mathbb{G}_1 \times \mathbb{G}_2 \to \mathbb{G}_T$ be a mapping to a target group $\mathbb{G}_T$ also of order $q$. 

\begin{definition}[Bilinear asymmetric group \cite{cryptoeprint:2016/440}]
\label{bilinear-group}

A tuple $(\mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T, q, e)$ is a \emph{bilinear asymmetric group} if the following hold.

\begin{itemize}

	\item Group operations in $\mathbb{G}_1, \mathbb{G}_2$, and $\mathbb{G}_T$ and mapping $e$ are efficiently computable.

	\item $e$ is bilinear. That is, for $x, y \in \Z_q$, $e(g_1^x, g_2^y) = e(g_1, g_2)^{xy}$.

	\item $e$ is non-degenerate. That is, $e(g_1, g_2) \neq 1$, the identity element of $\mathbb{G}_T$.

\end{itemize}

\end{definition}

For a vector $\mathbf{v} = (v_1, v_2, \cdots, v_n) \in \Z_q^n$ and a group element $g$ in group of order $q$, we write $g^\mathbf{v}$ to denote the vector of group elements $(g^{v_1}, g^{v_2}, \cdots, g^{v_n})$. Moreover, for $k \in \Z_q$ and $\mathbf{v}, \mathbf{w} \in \Z_q^n$, we write $(g^{\mathbf{v}})^k = g^{k \cdot \mathbf{v}}$ and $g^\mathbf{v} \cdot g^\mathbf{w} =  g^{\mathbf{v} + \mathbf{w}}$. Finally, the pairing operation is extended to vectors.
\[
	e(g_1^{\mathbf{v}}, g_2^{\mathbf{w}}) = \prod_{i \in [n]} e(g_1^{v_i}, g_2^{w_i}) = e(g_1, g_2)^{\langle \mathbf{v}, \mathbf{w} \rangle}.
\]

We now recall the fh-IPFE construction $\textsf{FE}$ in \cite{cryptoeprint:2016/440}.

\begin{itemize}

	\item $\textsf{FE.Setup}(1^\lambda)$: Sample an asymmetric bilinear group $(\mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T, q, e)$ and choose generators $g_1 \in \mathbb{G}_1$ and $g_2 \in \mathbb{G}_2$. Sample $\mathbf{B} \in \mathbb{GL}_n(\Z_q)$ and find $\mathbf{B}^* = \det(\mathbf{B}) \cdot (\mathbf{B}^{-1})^T$. Finally, output the public parameter $\textsf{pp} = (\mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T, q, e)$ and the master secret key $\textsf{msk} = (\textsf{pp}, g_1, g_2, \mathbf{B}, \mathbf{B}^*)$.
	
	\item $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x})$: Sample $\alpha \getsdollar \Z_q$ and output
	\[
		 \textsf{sk}_{\mathbf{x}} = (K_1, K_2) = \left( g_1^{\alpha \cdot \det(\mathbf{B})}, g_1^{\alpha \cdot \mathbf{x} \cdot \mathbf{B}} \right)
	\]
	
	\item $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y})$: Sample $\beta \getsdollar \Z_q$ and output
	\[
		 \textsf{ct}_{\mathbf{y}} = (C_1, C_2) = \left( g_2^{\beta}, g_2^{\beta \cdot \mathbf{y} \cdot \mathbf{B}^*} \right)
	\]
	
	\item $\textsf{FE.Dec}(\textsf{pp}, \textsf{sk}_{\mathbf{x}}, \textsf{ct}_{\mathbf{y}}) \to z$: Parse $\textsf{sk}_{\mathbf{x}} = (K_1, K_2)$ and $\textsf{ct}_{\mathbf{y}} = (C_1, C_2)$ and compute 
	\[
		D_1 = e(K_1, C_1) \quad \text{and} \quad D_2 = e(K_2, C_2)
	\]
	Solve the discrete logarithm to find $z$ such that $D_1^z = D_2$ and output $z$. If it fails to find such $z$, output $\bot$.

\end{itemize}

\paragraph{Correctness}
We have
\[
	D_1 = e(K_1, C_1) = e(g_1, g_2)^{\alpha \cdot \beta \cdot \det(\mathbf{B})}
\] and 
\[
	D_2 = e(K_2, C_2) = e(g_1, g_2)^{\alpha \cdot \beta \cdot \mathbf{x} \cdot \mathbf{B} \cdot (\mathbf{B}^*)^T \cdot \mathbf{y}^T \cdot } = e(g_1, g_2)^{\alpha \cdot \beta \cdot \det(\mathbf{B}) \cdot \mathbf{x}\mathbf{y}^T }.
\]
Therefore, $(D_1)^{\langle \mathbf{x}, \mathbf{y} \rangle} = D_2$.

\paragraph{Remark}
In this construction, $q$ is exponential to $\lambda$ to achieve security, and decryption relies on some priori knowledge of possible ranges of the inner product $\langle \mathbf{x}, \mathbf{y} \rangle$. For example, for the instantiation in Section \ref{sec:fh-IPFE-instantiation}, one can enumerate $z \in \{0, 1, \cdots, \tau \}$ and return $\bot$ when no valid $z \leq \tau$ such that $D_1^z = D_2$ is found.

%-------------------

\newpage

%-------------------

\section{$\gamma$-RUF Security of \textsf{FE}}

Let $\mathbb{F} = \Z_q$. We can extend the definition of the RUF security in Section \ref{sec:security_analysis:fh-IPFE:ruf} with an integer parameter $\gamma$.

\begin{figure}[H]
\centering

	\begin{minipage}[t]{0.55\textwidth}
	\begin{algorithm}[H]
	\caption{$\textsf{RUF}^{\mathcal{O}, \gamma}_{\textsf{FE}}(\mathcal{A})$}
	\label{alg:gamma-ruf-fh-IPFE}
	\begin{algorithmic}[1]
		\State $\mathbf{r} \getsdollar \mathbb{F}^{k}$

		\State $\textsf{msk}, \textsf{pp} \gets \textsf{FE.Setup}(1^\lambda)$

		\State $\textsf{sk}_{\mathbf{r}} \gets \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{r})$

		\State $\mathbf{\tilde{z}} \gets \mathcal{A}^{\mathcal{O}} ( \textsf{pp}, \textsf{sk}_{\mathbf{r}} )$

		\If{$\mathbf{\tilde{z}}$ is equal to any output of $\mathcal{O}^\prime_{\textsf{Enc}}$ }
			
			\State \Return $0$
		
		\EndIf

		\State $s \gets \textsf{FE.Dec}(\textsf{pp}, \textsf{sk}_{\mathbf{r}}, \mathbf{\tilde{z}} )$

		\State \Return $1_{s \leq \gamma}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\end{figure}

Here, the game runs $1_{s \leq \gamma}$ by first viewing the field element $s \in \Z_q$ as a positive integer in $\{0, 1, \cdots, q-1 \}$ and comparing it with $\gamma$.

The oracle $\mathcal{O}$ can be nothing or include $\mathcal{O}^\prime_{\textsf{KeyGen}}(\cdot)$ and $\mathcal{O}^\prime_{\textsf{Enc}}(\cdot)$ based on the threat model as in Section \ref{sec:security_analysis:fh-IPFE:ruf}.

\begin{definition}[$\gamma$-RUF Security]

	An fh-IPFE scheme \textsf{FE} is called $\{ \mathcal{O}, \gamma \}$-RUF secure if for any adversary $\mathcal{A}$, the advantage of $\mathcal{A}$ in the $\textsf{RUF}^{\mathcal{O}, \gamma}_\textsf{FE}$ game in Algorithm \ref{alg:gamma-ruf-fh-IPFE} is
\[
	\Adv_{\textsf{FE}, \mathcal{A}}^{\textsf{RUF}, \mathcal{O}, \gamma} := \Pr[\textsf{RUF}^{\mathcal{O}, \gamma}_{\textsf{FE}}(\mathcal{A}) \to 1 ] = \negl.
\]

\noindent Note that if $\textsf{FE}$ is $\mathcal{O}$-RUF secure, it is $\{ \mathcal{O}, \gamma \}$-RUF secure for any integer $\gamma$.
\end{definition}

With the extension with $\gamma$, we can rewrite our results in Section \ref{sec:security_analysis:fh-IPFE}.


\begin{theorem}[Theorem \ref{thm:fh-IPFE:ind-ruf-OB-Enroll}]
\label{thm:fh-IPFE:ind-gamma-ruf-OB-Enroll}
	Let $\textsf{option} = \{ \textsf{csk}, \mathbf{c_x}, \mathcal{O}_\mathcal{B}, \mathcal{O}_{\textsf{Enroll}} \}$. For any distribution family $\mathbb{B}$, if \textsf{FE} is fh-IND and $\{ \mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma \}$-RUF for a $\gamma \geq \tau^2$, then $\Pi$ is $\textsf{option}$-UF. 
\end{theorem}

\begin{theorem}[Theorem \ref{thm:fh-IPFE:ind-ruf-OB-Probe}]
\label{thm:fh-IPFE:ind-gamma-ruf-OB-Probe}
	Let $\textsf{option} = \{\textsf{csk}, \mathbf{c_x}, \mathcal{O}_\mathcal{B}, \mathcal{O}_\textsf{Probe}\}$. For any distribution family $\mathbb{B}$, if \textsf{FE} is fh-IND and $\{ \mathcal{O}^\prime_{\textsf{Enc}}, \gamma \}$-RUF for a $\gamma \geq \tau^2$, then $\Pi$ is $\textsf{option}$-UF. 
\end{theorem}

\subsection{Achievability of $\gamma$-RUF Security}

\begin{assumption}
\label{assump:only-return-valid-ct}
Assume that $\textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{z})$ only returns when $\mathbf{z}$ corresponds to a \emph{non-zero} vector $\mathbf{v} \in \mathbb{F}^k$. More precisely, assume that for any $\mathbf{z}$, there can only be two possibilities.

\begin{itemize}
	\item Either there exists a vector $\mathbf{v} \in \mathbb{F}^k \setminus \{\mathbf{0}\}$ such that for any $\mathbf{x} \in \mathbb{F}^k, \textsf{sk}_{\mathbf{x}} \gets \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x})$, 
	\[
		%\textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{z}) = \textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{c_v}).
		\textsf{FE.Dec}(\textsf{pp}, \textsf{sk}_{\mathbf{x}}, \mathbf{z}) = \langle \mathbf{x}, \mathbf{v} \rangle.
	\]
	\item Or for any $\mathbf{x} \in \mathbb{F}^k$ and $\textsf{sk}_{\mathbf{x}} \gets \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x})$, $\textsf{FE.Dec}(\textsf{pp}, \textsf{sk}_{\mathbf{x}}, \mathbf{z}) \to \bot$.

\end{itemize}
Note that this implies $\textsf{FE}$ rejects the zero vector $\mathbf{0}$ as the input of $\textsf{FE.Enc}$.
\end{assumption}

\begin{theorem}
\label{thm:fh-IPFE:ind-OKeyGen-gamma-ruf}
Given Assumption \ref{assump:only-return-valid-ct}. If \textsf{FE} is fh-IND, then $\textsf{FE}$ is $\{ \mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma \}$-RUF for any $\gamma \leq (1 - \frac{1}{\poly}) \cdot \|\mathbb{F}\|$.

\end{theorem}

\begin{proof}
Given an adversary $\mathcal{A}$ in the $\textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}_{\textsf{FE}}$ game for a $\gamma \leq (1 - \frac{1}{P(\lambda)}) \cdot \|\mathbb{F}\|$, where $P(\lambda)$ is any polynomial. Let $t$ be an integer, consider the reduction adversary $\mathcal{R}$ in Algorithm \ref{alg:red:ind-OKeyGen-gamma-ruf} which plays the \textsf{fh-IND} game. $\mathcal{R}$ simulates $\mathcal{O}_\textsf{KeyGen}^\prime(\mathbf{x}^\prime)$ by $\mathcal{O}_\textsf{KeyGen}(\mathbf{x}^\prime, \mathbf{x}^\prime)$.
If there exists an $s_i \neq \bot$ in Line \ref{alg:red:ind-OKeyGen-gamma-ruf:s}, by Assumption \ref{assump:only-return-valid-ct}, let $\mathbf{\tilde{z}}$ correspond to a non-zero vector $\mathbf{\tilde{v}}$.

\begin{figure}[h]
\centering
	
	\begin{minipage}[t]{0.5\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\mathcal{R}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}}(\textsf{pp})$}
	\label{alg:red:ind-OKeyGen-gamma-ruf}
	\begin{algorithmic}[1]
		\State $\mathbf{r}^{(0)}, \mathbf{r}^{(1)} \getsdollar \mathbb{F}^{k}$
		
		\State $\textsf{sk} \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{r}^{(0)}, \mathbf{r}^{(1)})$ 

		\State ${\mathbf{\tilde{z}}} \gets {\mathcal{A}}^{\mathcal{O}^\prime_{\textsf{KeyGen}}} (\textsf{pp}, \textsf{sk})$

		\For{$i = 1$ to $t$}
		
			\State $\mathbf{r}_i \getsdollar \mathbb{F}^{k}$

			\State $\textsf{sk}_i \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{r}^{(0)}, \mathbf{r}_i)$

			\State $s_i \gets \textsf{FE.Dec}( \textsf{pp}, \textsf{sk}_i, \mathbf{\tilde{z}} )$ \label{alg:red:ind-OKeyGen-gamma-ruf:s}
	
		\EndFor	
		
		\If{$\bigwedge_{i=1}^t s_i \leq \gamma$} \label{alg:red:ind-OKeyGen-gamma-ruf:verify}
			\State \Return $\tilde{b} = 0$
		\Else
			\State \Return $\tilde{b} \getsdollar \{0, 1\}$
		\EndIf

	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\end{figure}


If the challenge bit $b = 0$, then by Assumption \ref{assump:only-return-valid-ct}, any $s_i \neq \bot$ in Line \ref{alg:red:ind-OKeyGen-gamma-ruf:s} implies all $s_i \neq \bot$ and $s_i = s_j$ for any $i, j$. Therefore, the probability that all $s_i \leq \gamma$ in Line \ref{alg:red:ind-OKeyGen-gamma-ruf:verify} is
\begin{align*}
	\Pr\left[ \bigwedge_{i=1}^t s_i \leq \gamma \mid b = 0 \right]
	&= \Pr\left[ s_1 \neq \bot \mid b = 0 \right] \cdot \Pr \left[ s_1 \leq \gamma \mid b = 0 \wedge s_1 \neq \bot \right] \\
	&= \Pr \left[ s_1 \neq \bot \mid b = 0 \right] \cdot \Pr \left[ \langle \mathbf{r}^{(0)}, \mathbf{\tilde{v}} \rangle \leq \gamma \mid b = 0 \wedge s_1 \neq \bot \right] \\
	&= \Pr \left[s_1 \neq \bot \mid b = 0 \right] \cdot \Pr \left[ \textsf{FE.Dec}(\textsf{pp}, \textsf{sk}, \mathbf{\tilde{z}}) \leq \gamma \mid b = 0 \wedge s_1 \neq \bot \right] \\
	&= \Pr \left[s_1 \neq \bot \mid b = 0 \right] \cdot \Pr \left[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1 \mid b = 0 \wedge s_1 \neq \bot \right] \\ 
	&= \Pr \left[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1 \right] 
\end{align*}

If the challenge bit $b = 1$, for any $i \in [t]$,
\begin{align*}
	\Pr[ s_i \leq \gamma \mid b = 1 ]
	&= \Pr[s_i \neq \bot \mid b = 1] \cdot \Pr[ s_i \leq \gamma \mid b = 1 \wedge s_i \neq \bot] \\
	&= \Pr[s_i \neq \bot \mid b = 1] \cdot \Pr[ \langle \mathbf{r}_i, \mathbf{\tilde{v}} \rangle \leq \gamma \mid b = 1 \wedge s \neq \bot]
\end{align*}
Note that $\mathbf{r}_i$ is independent of $\mathbf{\tilde{z}}$ and thus independent of $\mathbf{\tilde{v}}$. Hence, $\Pr[ \langle \mathbf{r}_i, \mathbf{\tilde{v}} \rangle \leq \gamma \mid b = 1 \wedge s_i \neq \bot] = \frac{\gamma}{\| \mathbb{F} \|}$ and
\[
	\Pr \left[ \bigwedge_{i=1}^t s_i \leq \gamma \mid b = 1 \right] = \Pr \left[ \bigwedge_{i=1}^t s_i \neq \bot \mid b = 1 \right] \cdot \left( \frac{\gamma}{\| \mathbb{F} \|} \right)^t \leq \left( \frac{\gamma}{\| \mathbb{F} \|} \right)^t
\]

In conclusion,
\begin{align*}
	\Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] 
	&= \frac{1}{2} + \frac{1}{4} \left( \Pr \left[ \bigwedge_{i=1}^t s_i \leq \gamma \mid b = 0 \right] - \Pr \left[ \bigwedge_{i=1}^t s_i \leq \gamma \mid b = 1 \right] \right) \\
	&\geq \frac{1}{2} + \frac{1}{4} \left( \Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1] - \left( \frac{\gamma}{\| \mathbb{F} \|} \right)^t \right) \\
	&\geq \frac{1}{2} + \frac{1}{4} \left( \Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1] -  e^{- t \cdot (1 - \frac{\gamma}{\| \mathbb{F} \|}) } \right) \\
	&\geq \frac{1}{2} + \frac{1}{4} \left( \Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1] -  e^{- \frac{t}{P(\lambda)} } \right)
\end{align*}

\noindent Take $t$ be any integer larger than $P(\lambda) \cdot \lambda$. Since $\Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} = \left| \Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] - \frac{1}{2} \right|$ and $e^{-t \cdot \frac{1}{P(\lambda)}} < e^{-\lambda}$ are negligible,
\[
	\Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1]  \leq e^{- \frac{t}{P(\lambda)} } + 4 \cdot \Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND}  = \negl.
\]

\end{proof}

%-------------------

\newpage

%-------------------


\section{Summary of UF and IND Security}

\begin{table}[ht]
\centering
\begin{tabular}{c c c} 
	
	\toprule

	& \textbf{UF} & \textbf{IND} \\
	
	\midrule

	\textsf{fh-IND} & \xmark \; (Thm \ref{thm:fh-IPFE-not-uf}) & $\{ \textsf{csk}, \mathbf{c_x},  \mathcal{O}_{\mathbf{c_y}} \}$ (Thm \ref{thm:fh-IPFE:ind-ind}) \\
	
	\midrule
	
	\textsf{fh-IND}, $\mathcal{O}^\prime_{\textsf{KeyGen}}$-RUF & $\{ \textsf{csk}, \mathbf{c_x}, \mathcal{O}_\mathcal{B}, \mathcal{O}_{\textsf{Enroll}} \}$ (Thm \ref{thm:fh-IPFE:ind-ruf-OB-Enroll}) & $\{ \textsf{csk}, \mathbf{c_x},  \mathcal{O}_{\mathbf{c_y}} \}$ (Thm \ref{thm:fh-IPFE:ind-ind}) \\
	
	\midrule
	
	\textsf{fh-IND}, $\mathcal{O}^\prime_{\textsf{Probe}}$-RUF & $\{ \textsf{csk}, \mathbf{c_x}, \mathcal{O}_\mathcal{B}, \mathcal{O}_{\textsf{Probe}} \}$ (Thm \ref{thm:fh-IPFE:ind-ruf-OB-Probe}) & $\{ \textsf{csk}, \mathbf{c_x},  \mathcal{O}_{\mathbf{c_y}} \}$ (Thm \ref{thm:fh-IPFE:ind-ind}) \\
	
	\midrule
	
	\textsf{fh-IND} + sEUF-CMA \textsf{Sig} & $\{ \textsf{esk}, \textsf{csk}, \mathbf{c_x}, \mathcal{O}_\mathcal{B}, \mathcal{O}_{\textsf{Probe}} \}$ (Thm \ref{thm:sEUF-CMA-esk-csk}) & $\{ \textsf{csk}, \mathbf{c_x},  \mathcal{O}_{\mathbf{c_y}} \}$ (Thm \ref{thm:fh-IPFE:ind-ind}) \\
	
	\midrule
	
	\textsf{fh-IND} + MC-IND-CPA \textsf{PKE} & \xmark \; (Thm \ref{thm:fh-IPFE-not-uf})  & \makecell{$\{ \textsf{csk}, \mathbf{c_x},  \mathcal{O}_{\mathbf{c_y}} \}$ (Thm \ref{thm:fh-IPFE:ind-ind}) \\ $\{ \textsf{esk}, \textsf{psk}, \mathbf{c_x}, \mathcal{O}_{\mathbf{c_y}} \}$ (Thm \ref{thm:mc-ind-cpa:ind-esk-psk})} \\
	
	\midrule
	
	\makecell{\textsf{fh-IND} + sEUF-CMA \textsf{Sig} \\ + MC-IND-CPA \textsf{PKE}} & $\{ \textsf{esk}, \textsf{csk}, \mathbf{c_x}, \mathcal{O}_\mathcal{B}, \mathcal{O}_{\textsf{Probe}} \}$ (Thm \ref{thm:sEUF-CMA-esk-csk}) & \makecell{$\{ \textsf{csk}, \mathbf{c_x},  \mathcal{O}_{\mathbf{c_y}} \}$ (Thm \ref{thm:fh-IPFE:ind-ind}) \\ $\{ \textsf{esk}, \textsf{psk}, \mathbf{c_x}, \mathcal{O}_{\mathbf{c_y}} \}$ (Thm \ref{thm:mc-ind-cpa:ind-esk-psk})} \\
	
	\bottomrule

\medskip
\end{tabular}
\caption{fh-IPFE. We can try to provide \textsf{option}-UF with \textsf{psk}.}
\label{table:fh-IPFE}
\end{table}



\begin{table}[ht]
\centering
\begin{tabular}{c c c} 
	
	\toprule

	& \textbf{UF} & \textbf{IND} \\
	
	\midrule

	Unforgeable for $\mathcal{X}$ & $\{ \textsf{esk}, \textsf{psk}, \textsf{csk}, \mathbf{c_x} \}$ (Thm \ref{thm:rh:uf-uf-cx}) & \xmark \; (Thm \ref{thm:ind-tp-fp}) \\
	
	\midrule
	
	\makecell{Unforgeable for $\mathcal{X}$ \\ + sEUF-CMA \textsf{Sig}} & \makecell{ $\{ \textsf{esk}, \textsf{psk}, \textsf{csk}, \mathbf{c_x} \}$ (Thm \ref{thm:rh:uf-uf-cx}) \\ $\{ \textsf{esk}, \textsf{csk}, \mathbf{c_x}, \mathcal{O}_\mathcal{B}, \mathcal{O}_{\textsf{Probe}} \}$ (Thm \ref{thm:sEUF-CMA-esk-csk}) } & \xmark \; (Thm \ref{thm:ind-tp-fp}) \\
	
	\midrule
	
	\makecell{ Unforgeable for $\mathcal{X}$ \\+ MC-IND-CPA \textsf{PKE}} & $\{ \textsf{esk}, \textsf{psk}, \textsf{csk}, \mathbf{c_x} \}$ (Thm \ref{thm:rh:uf-uf-cx}) & \makecell{$\{ \textsf{esk}, \textsf{psk}, \mathbf{c_x}, \mathcal{O}_{\mathbf{c_y}} \}$ (Thm \ref{thm:mc-ind-cpa:ind-esk-psk})} \\
	
	\midrule
	
	\makecell{Unforgeable for $\mathcal{X}$ \\ + sEUF-CMA \textsf{Sig} \\ + MC-IND-CPA \textsf{PKE}} & \makecell{ $\{ \textsf{esk}, \textsf{psk}, \textsf{csk}, \mathbf{c_x} \}$ (Thm \ref{thm:rh:uf-uf-cx}) \\ $\{ \textsf{esk}, \textsf{csk}, \mathbf{c_x}, \mathcal{O}_\mathcal{B}, \mathcal{O}_{\textsf{Probe}} \}$ (Thm \ref{thm:sEUF-CMA-esk-csk}) }  & \makecell{$\{ \textsf{esk}, \textsf{psk}, \mathbf{c_x}, \mathcal{O}_{\mathbf{c_y}} \}$ (Thm \ref{thm:mc-ind-cpa:ind-esk-psk})} \\
	
	\bottomrule

\medskip
\end{tabular}
\caption{RH. We can try to provide \textsf{option}-IND with \textsf{csk}.}
\label{table:rh}
\end{table}

%-------------------

\newpage

%-------------------


\section{One-Way Game}

\begin{figure}[h]
\centering

	\begin{minipage}[t]{0.55\textwidth}
	\begin{algorithm}[H]
	\caption{$\textsf{OW}_{\Pi, \mathbb{B}, \textsf{option}}(\mathcal{A})$}
	\label{alg:ow_game}
	\begin{algorithmic}[1]

		\State $\mathcal{B} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$

		\State $\textsf{esk}, \textsf{psk}, \textsf{csk} \gets \textsf{Setup}(1^\lambda)$

		\State $\mathbf{b} \gets \textsf{getEnroll}^{\mathcal{O}_{\mathcal{B}}}()$

		\State $\mathbf{c_x} \gets \textsf{Enroll}(\textsf{esk}, \mathbf{b})$

		\State $\mathbf{\tilde{b}} \gets \mathcal{A}( \textsf{option} )$

		\State $s \gets \textsf{BioCompare}(\mathbf{b}, \mathbf{\tilde{b}})$
		\State \Return $ \textsf{Verify}(s) $
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\label{fig:ow_game}
\end{figure}

The auxiliary information \textsf{option} can be nothing or include $\textsf{esk}, \textsf{psk}, \textsf{csk}, \mathbf{c_x}$ or the oracles $\mathcal{O}_{\mathbf{c_y}}, \mathcal{O}_{\textsf{Enroll}}, \mathcal{O}_{\textsf{Probe}}, \mathcal{O}^\prime_{\textsf{Enroll}}, \mathcal{O}^\prime_{\textsf{Probe}}$. We can also consider providing $\mathbf{c_x}^{(i)} \gets \textsf{Enroll}(\textsf{esk}_i, \mathbf{b})$ for different honest $\textsf{esk}_i$. Note that the \textsf{OW} game is trivial if \textsf{FP} is not negligible.

We define the advantage of an adversary $\mathcal{A}$ in the $\textsf{OW}_{\Pi, \mathbb{B}, \textsf{option}}$ game of a scheme $\Pi$ associated with a family $\mathbb{B}$ of distributions as
\[
	\Adv^{\textsf{OW}}_{\Pi, \mathbb{B}, \mathcal{A}, \textsf{option}} := \Pr[\textsf{OW}_{\Pi, \mathbb{B}, \textsf{option}}(\mathcal{A}) \to 1]
\]

An authentication scheme $\Pi$ associated with a family $\mathbb{B}$ of distributions is called \emph{\textsf{option}-one-way} (\textsf{option}-OW) if for any PPT adversary $\mathcal{A}$,
\[
	\Adv^{\textsf{OW}}_{\Pi, \mathbb{B}, \mathcal{A}, \textsf{option}} = \negl.
\]

Its relation with UF security is as follows.

\begin{theorem}
	Let $\textsf{option}$ include $\textsf{psk}$. If $\Pi$ is $\textsf{option}$-UF, then $\Pi$ is $\textsf{option}$-OW.
\end{theorem}

\begin{proof}
	Suppose $\Pi$ is not $\textsf{option}$-OW, the adversary can derive $\tilde{\mathbf{b}}$ such that 
	\[
		\textsf{Verify}(\textsf{BioCompare}(\mathbf{b}, \tilde{\mathbf{b}})) = 1
	\]
	With $\textsf{psk}$, the adversary can further generate $\tilde{\mathbf{c_x}} \gets \textsf{Probe}(\textsf{psk}, \tilde{\mathbf{b}})$ to win the \textsf{option-UF} game.
\end{proof}

\begin{assumption}
\label{assump:consistent}
	Assume that for any $\mathcal{B}^{(0)}, \mathcal{B}^{(1)} \in \mathbb{B}$, $\mathcal{B}^{(0)} \neq \mathcal{B}^{(1)}$, and $\tilde{\mathbf{b}}$ in the domain of $\mathsf{BioCompare}$, let $\mathbf{b}^{(0)}, \mathbf{b}^{(0) \prime} \gets \mathsf{getEnroll}^{\mathcal{O}_{\mathcal{B}^{(0)}}}()$ and $\mathbf{b}^{(1) \prime} \gets \mathsf{getEnroll}^{\mathcal{O}_{\mathcal{B}^{(1)}}}()$, then
	\begin{align*}
		& \Pr[\mathsf{Verify}(\mathsf{BioCompare}(\mathbf{b}^{(0)\prime}, \tilde{\mathbf{b}})) = 1 \mid \mathsf{Verify}(\mathsf{BioCompare}(\mathbf{b}^{(0)}, \tilde{\mathbf{b}})) = 1] \\
		& - \Pr[\mathsf{Verify}(\mathsf{BioCompare}(\mathbf{b}^{(1)}, \tilde{\mathbf{b}})) = 1 \mid \mathsf{Verify}(\mathsf{BioCompare}(\mathbf{b}^{(0)}, \tilde{\mathbf{b}})) = 1] \geq \frac{1}{\poly}.
	\end{align*}
\end{assumption}

\begin{theorem}
	Given Assumption \ref{assump:consistent}. If $\Pi$ is $\textsf{option}$-IND, then $\Pi$ is $\textsf{option}$-OW.
\end{theorem}

\begin{proof}
	Suppose $\Pi$ is not \textsf{option}-OW, we can construct an adversary in the \textsf{option}-{IND} game that can derive $\tilde{\mathbf{b}}$ such that 
	\[
		\textsf{Verify}(\textsf{BioCompare}(\mathbf{b}, \tilde{\mathbf{b}})) = 1
	\]
	where $\mathbf{b} \gets \textsf{getEnroll}^{\mathcal{O}_{\mathcal{B}^{(b)}}}()$ and $b$ is the challenge bit. By assumption \ref{assump:consistent}, this implies that if the adversary runs $\mathbf{b}^{(0)\prime} \gets \mathsf{getEnroll}^{\mathcal{O}_{\mathcal{B}^{(0)}}}()$ and $\mathbf{b}^{(1) \prime} \gets \mathsf{getEnroll}^{\mathcal{O}_{\mathcal{B}^{(1)}}}()$, then
	\begin{gather*}
		\Pr[\mathsf{Verify}(\mathsf{BioCompare}(\mathbf{b}^{(b)\prime}, \tilde{\mathbf{b}})) = 1]  - \Pr[\mathsf{Verify}(\mathsf{BioCompare}(\mathbf{b}^{(1-b)\prime}, \tilde{\mathbf{b}})) = 1] \geq \frac{1}{\poly}.
	\end{gather*}
	By comparing the results of the two cases, the adversary can find $b$ with a probability greater than $\frac{1}{\poly}$.
\end{proof}
We have seen some examples that authentication schemes using current constructions of fh-IPFE and RH may not be OW-secure.

\paragraph{fh-IPFE}

Suppose $\Pi$ is instantiated by the construction in \cite{cryptoeprint:2016/440} in the way described in Section \ref{sec:fh-IPFE-instantiation}. The scheme is not $\mathcal{O}_{\textsf{Enroll}}^\prime$-OW. The adversary can set the fake $\textsf{esk}^\prime$ to include the matrix $\mathbf{B} = \mathbf{I}$, the size-$(k+2)$ identity matrix, and query $\mathcal{O}_{\textsf{Enroll}}^\prime$ to get
\[
	g_1^{\alpha \cdot \det(\mathbf{B})}, g_1^{\alpha \cdot \mathbf{x} \cdot \mathbf{B}} = g_1^{\alpha}, (g_1^{\alpha \cdot {x_1}}, g_1^{\alpha \cdot {x_2}}, g_1^{\alpha \cdot {x_{k+2}}}) 
\]
where $\alpha$ is an unknown element in $\Z_q$, and $\mathbf{x} = (x_1, \cdots, x_{k+2}) = (b_1, \cdots, b_k, 1, \|\mathbf{b}\|^2)$. Since $b_i$ is bounded in $\{0, 1, \cdots, m\}$ for some fixed integer $m$ for each $i$, the adversary can raise the power of $g_1^{\alpha}$ to retrive all the coefficients of $\mathbf{b}$. Similarly, the scheme is not $\mathcal{O}_{\textsf{Probe}}^\prime$-OW.

In addition, any fh-IPFE scheme instantiated in the way described in Section \ref{sec:fh-IPFE-instantiation} is neither $\{ \mathbf{c_x}, \textsf{esk} \}$-OW nor $\{ \mathbf{c_x}, \textsf{psk} \}$-OW. Note that $\textsf{esk} = \textsf{psk} = \textsf{msk}$, the master secret key of the fh-IPFE. With $\textsf{msk}$, the adversary can generate encryptions of any vector and find $\mathbf{x}$ by solving linear equations of inner products.

\paragraph{RH}

Suppose $\Pi$ is instantiated by the construction in \cite{cryptoeprint:2014/394} in the way described in Section \ref{sec:rh-instantiation}. The scheme is neither $\mathcal{O}_{\textsf{Enroll}}^\prime$-OW nor $\mathcal{O}_{\textsf{Probe}}^\prime$-OW. Recall that the enrollment key $\textsf{esk}$ is the public key $\textsf{pk}$ of the relational hash scheme. In the construction of \cite{cryptoeprint:2014/394},
\begin{itemize}
	\item $\textsf{pk}$ includes an encoding algorithm $\textsf{Encode}$ of an error correcting code.
	\item $\mathbf{h_x}$ includes $\mathbf{x} + \textsf{Encode}(\mathbf{r})$ for some random $\mathbf{r} \getsdollar \{0,1\}^k$.
\end{itemize}
Now, the adversary can set the fake $\textsf{esk}^\prime$ to include an invalid $\textsf{Encode}$ such that $\mathbf{x} + \textsf{Encode}(\mathbf{r})$ reveals $\mathbf{x} = \mathbf{b}$. 

The scheme is $\{ \textsf{esk}, \textsf{psk}, \textsf{csk}, \mathbf{c_x} \}$-OW, which is given in \cite[Theorem 4]{cryptoeprint:2014/394}.

%-------------------

\newpage

%-------------------

\section{Fixing the Proof of Theorem \ref{thm:fh-IPFE:ind-ruf-OB-Probe}}

In Theorem \ref{thm:fh-IPFE:ind-ruf-OB-Probe}, we simulate the oracle $\mathcal{O}_{\textsf{Probe}}$ in the adversary $\mathcal{A}^\prime$ in Algorithm \ref{alg:adv:ind-uf-OB-Probe} in the $\textsf{RUF}^{ \mathcal{O}^\prime_{\textsf{Enc}} }$ game by the following steps:

\begin{enumerate}

\item Sample $k+2$ independent vectors $\mathbf{e}^{(1)}, \cdots, \mathbf{e}^{(k+2)}$.

\item For $i \in [k+2]$, $\textsf{ct}^{(i)} \gets \mathcal{O}^\prime_{\textsf{Enc}}(\mathbf{e}^{(i)})$.

\item For $i \in [k+2]$,  $d_i \gets \textsf{FE.Dec}(\textsf{pp}, \textsf{sk}_{\mathbf{r}}, \mathbf{c}^{(i)})$, where $\textsf{sk}_{\mathbf{r}}$ is $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{r})$.

\item Find the vector $\mathbf{r}$ by solving the linear system $\{ \langle \mathbf{r}, {\mathbf{e}^{(i)}} \rangle = d_i \}_{i=1}^{k+2}$.

\item On query $\mathcal{O}_{\textsf{Probe}}(\mathbf{b}^\prime)$, first encode $\mathbf{b}^\prime$ into $\mathbf{y}^\prime$ and find $d \gets \langle \mathbf{x}^{*}, {\mathbf{y}^\prime} \rangle$. Then find a vector $\mathbf{y}^{\prime\prime}$ such that $ \langle \mathbf{r}, {\mathbf{y}^{\prime\prime}} \rangle = d$. Return $\mathcal{O}^\prime_{\textsf{Enc}}(\mathbf{y}^{\prime\prime})$.

\end{enumerate}

However, $\textsf{FE.Dec}$ of constructions in \cite{cryptoeprint:2015/1255, 10.1007/978-3-319-45871-7_24, cryptoeprint:2016/440} rely on some \emph{prior knowledge} of the inner product. Their basic idea is to find $d$ given $g$ and $g^d$, where $g$ is in a group of exponential size. Therefore, $\textsf{FE.Dec}(\textsf{pp}, \textsf{sk}_{\mathbf{r}}, \mathbf{c}^{(i)})$ will probably return $\bot$, representing that $d$ is too large to find.

For this problem, I have three proposals:
\begin{enumerate}
	\item Let the adversary choose $\mathbf{r}$.

	\item Modify the $\textsf{RUF}$ game. 

	\item Do nothing. Claim \cite{cryptoeprint:2015/1255, 10.1007/978-3-319-45871-7_24, cryptoeprint:2016/440} are not ideal \textsf{FE}.
\end{enumerate}

\subsection{Solution I}
Consider the \textsf{SUF} game.
\begin{figure}[H]
\centering

	\begin{minipage}[t]{0.55\textwidth}
	\begin{algorithm}[H]
	\caption{$\textsf{SUF}^{\mathcal{O}}_{\textsf{FE}}(\mathcal{A} = (\mathcal{A}_1, \mathcal{A}_2))$}
	\begin{algorithmic}[1]
		\State $\mathbf{r}, \textsf{st} \gets \mathcal{A}_1(1^\lambda)$

		\If{$\mathbf{r} = \mathbf{0}$}
			\State \Return $\bot$
		\EndIf

		\State $\textsf{msk}, \textsf{pp} \gets \textsf{FE.Setup}(1^\lambda)$

		\State $\textsf{sk}_{\mathbf{r}} \gets \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{r})$

		\State $\mathbf{\tilde{z}} \gets \mathcal{A}_2^{\mathcal{O}} ( \textsf{st}, \textsf{pp}, \textsf{sk}_{\mathbf{r}} )$

		\If{$\mathbf{\tilde{z}}$ is equal to any output of $\mathcal{O}^\prime_{\textsf{Enc}}$ }
			
			\State \Return $0$
		
		\EndIf

		\State $s \gets \textsf{FE.Dec}(\textsf{pp}, \textsf{sk}_{\mathbf{r}}, \mathbf{\tilde{z}} )$

		\State \Return $1_{s \neq \bot}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\end{figure}

$\mathbf{r} \neq 0$ is because for constructions \cite{10.1007/978-3-319-45871-7_24, cryptoeprint:2016/440}, there exists an algorithm $\textsf{RandEnc}(\textsf{pp})$ that can generate ciphertexts $\textsf{FE.Enc}(\textsf{msk}, \mathbf{r}^\prime)$ of a random unknown vector $\mathbf{r}^\prime$.

I call this security property \emph{selective unforgeability (SUF)}. An SUF \textsf{FE} is RUF since the adversary $\mathcal{A}_1$ can choose $\mathbf{r} \getsdollar \mathbb{F}^k$. We can also add a signature scheme to an \textsf{FE} to make it SUF. Moreover, if we use SUF security, we do not need fh-IND security in our main results in \ref{sec:security_analysis:fh-IPFE:uf}. One can reduce \textsf{option}-UF security of $\Pi$ to SUF security of $\textsf{FE}$ in a simple and intuitive way.

\begin{theorem}[Revision of Theorem \ref{thm:fh-IPFE:ind-ruf-OB-Enroll}]
	Let $\textsf{option} = \{ \mathbf{c_x}, \textsf{csk}, \mathcal{O}_\mathcal{B}, \mathcal{O}_{\textsf{Enroll}} \}$. For any distribution family $\mathbb{B}$, if either one of the following is satisfied:
	\begin{itemize}
		\item \textsf{FE} is both fh-IND and $\mathcal{O}^\prime_{\textsf{KeyGen}}$-RUF (Theorem \ref{thm:fh-IPFE:ind-ruf-OB-Enroll})
		\item \textsf{FE} is $\mathcal{O}^\prime_{\textsf{KeyGen}}$-SUF
	\end{itemize}
then $\Pi$ is $\textsf{option}$-UF. 
\end{theorem}

\begin{theorem}[Revision of Theorem \ref{thm:fh-IPFE:ind-ruf-OB-Probe}]
	Let $\textsf{option} = \{ \mathbf{c_x}, \textsf{csk}, \mathcal{O}_\mathcal{B}, \mathcal{O}_{\textsf{Probe}} \}$. For any distribution family $\mathbb{B}$, if \textsf{FE} is $\mathcal{O}^\prime_{\textsf{Enc}}$-SUF, then $\Pi$ is $\textsf{option}$-UF. 
\end{theorem}

We can also leave both RUF and SUF security.

\subsection{Solution II}

Instead of sampling $\mathbf{r} \getsdollar \mathbb{F}^{k}$, one samples $\mathbf{r} \getsdollar \{0, 1\}^{k+2}$.
\begin{enumerate}

	\item Pick $k+2$ random one-hot vectors $\mathbf{e}^{(i)} \gets (0, \cdots, \overset{i\text{th}}{u_i}, \cdots, 0)$, where $u \getsdollar \mathbb{F}$.

	\item For $i \in [k+2]$, $\textsf{ct}^{(i)} \gets \mathcal{O}^\prime_{\textsf{Enc}}(\mathbf{e}^{(i)})$.

	\item For $i \in [k+2]$, $d_i \gets \textsf{FE.Dec}(\textsf{pp}, \textsf{sk}_{\mathbf{r}}, \textsf{ct}^{(i)})$. Note that $d_i$ can only be $u_i$ or $0$.

	\item Find the vector $\mathbf{r} \in \{0, 1\}^{k+2}$.

	\item On query $\mathcal{O}_{\textsf{Probe}}(\mathbf{b}^\prime)$, first encode $\mathbf{b}^\prime$ into $\mathbf{y}^\prime$ and find $d \gets \langle \mathbf{x}^{*}, {\mathbf{y}^\prime} \rangle$. Then find a vector $\mathbf{y}^{\prime\prime}$ such that $\langle \mathbf{r}, {\mathbf{y}^{\prime\prime}} \rangle = d$. Return $\mathcal{O}^\prime_{\textsf{Enc}}(\mathbf{y}^{\prime\prime})$.

\end{enumerate}

\subsection{Solution III}

We can say these fh-IPFE constructions \cite{cryptoeprint:2015/1255, 10.1007/978-3-319-45871-7_24, cryptoeprint:2016/440} are not \emph{ideal}. Their $\textsf{FE.Dec}$ often aborts on unrestricted inputs. On the contrary, constructions like \cite{10.1007/978-3-030-90567-5_33} do not need discrete logarithm in $\textsf{FE.Dec}$. Unfortunately, it is not \textsf{fh-IND} secure.

%-------------------

\newpage

%-------------------

\section{Trace users with different identities}

The work \cite{simoens2012framework} discusses a security concept related to reusability. It is called \emph{Trace users with different identities}. It is about when a user registers multiple records of its biometrics on the database. The server or compromised database should not be able to find that two records correspond to the same person.

Based on this concept, I design the following games. $\mathcal{S}_{\textsf{Enroll}}$ and $\mathcal{S}_{\textsf{Probe}}$ are two simulators that do not have access to $\mathbb{B}$.

\begin{figure}[H]
\centering

	\begin{minipage}[t]{0.45\textwidth}
	\begin{algorithm}[H]
	\caption{$\textsf{REU}_{\Pi, \mathbb{B}}(\mathcal{A})$}
	\begin{algorithmic}[1]
		\State $b \getsdollar \{0, 1\}$

		\State $\mathcal{B} \getsdollar \mathbb{B}, \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$

		\State $\tilde{b} \gets \mathcal{A}^{\mathcal{O}_{\textsf{Reg}}, \mathcal{O}_{\textsf{auth}}}(1^\lambda)$
 
		\State \Return $1_{\tilde{b} = b}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\end{figure}

\begin{itemize}
	\item $\mathcal{O}_{\textsf{Reg}}$: It maintains a table $\mathcal{T}$ and a counter $i$ initialized to $0$ at the beginning. On query, it updates $i \gets i+1$, and behaves depending on $b$:
	\begin{itemize}
		\item If $b = 0$: It generates key triplets $(\textsf{esk}_i, \textsf{psk}_i, \textsf{csk}_i) \gets \textsf{Setup}(1^\lambda)$, samples an enrollment template $\mathbf{b} \getsdollar \textsf{getEnroll}^{\mathcal{O}_{\mathcal{B}}}()$, stores an entry $\textsf{psk}_i$ in $\mathcal{T}[i]$, and outputs $\mathbf{c_x}_i \gets \textsf{Enroll}(\textsf{esk}_i, \mathbf{b})$ and $\textsf{csk}_i$.

		\item If $b = 1$: It generates key triplets $(\textsf{esk}_i, \textsf{psk}_i, \textsf{csk}_i) \gets \textsf{Setup}(1^\lambda)$, samples a biometric distribution $\mathcal{B}_i \getsdollar \mathbb{B}$ and an enrollment template $\mathbf{b}_i \getsdollar \textsf{getEnroll}^{\mathcal{O}_{\mathcal{B}_i}}()$, stores an entry $(\textsf{psk}_i, \mathcal{B}_i)$ in $\mathcal{T}[i]$, and outputs $\mathbf{c_x}_i \gets \textsf{Enroll}(\textsf{esk}_i, \mathbf{b}_i)$ and $\textsf{csk}_i$.
	\end{itemize}

	\item $\mathcal{O}_{\textsf{auth}}(i)$: This oracle has access to the table $\mathcal{T}$. On input $i$, it retrieves the entry $\mathcal{T}[i]$ and behaves depending on $b$:
	\begin{itemize}
		\item If $b = 0$: Let $\textsf{psk}_i \gets \mathcal{T}[i]$. It samples a probe template $\mathbf{b} \getsdollar \textsf{getProbe}^{\mathcal{O}_{\mathcal{B}}}()$ and outputs $\mathbf{c_y}_i \gets \textsf{Probe}(\textsf{psk}_i, \mathbf{b})$.

		\item If $b = 1$: Let $(\textsf{psk}_i, \mathcal{B}_i) \gets \mathcal{T}[i]$. It samples a probe template $\mathbf{b}_i \getsdollar \textsf{getProbe}^{\mathcal{O}_{\mathcal{B}_i}} ()$ and outputs $\mathbf{c_y}_i \gets \textsf{Probe}(\textsf{psk}_i, \mathbf{b}_i)$.
	\end{itemize}
	
\end{itemize}
If any adversary $\mathcal{A}$ cannot recover the bit $b$; that is, if $\Pr[ \textsf{REU}(\mathcal{A}) \to 1 ] = \negl.$, then a real-world server cannot distinguish whether a list of enrollment records all corresponding to the same person or not.

To provide more power for the adversary, we can also consider the following oracles.

\begin{itemize}
	\item $\mathcal{O}_{\textsf{Reg}}^\prime(\textsf{esk}^\prime)$: This oracle maintains a table $\mathcal{T}$ and a counter $i$ initialized to $0$ at the beginning. If $\textsf{esk}^\prime$ has been queried before, it aborts. Otherwise, it updates $i \gets i+1$ and behaves depending on $b$:
	\begin{itemize}
		\item If $b = 0$: It samples an enrollment template $\mathbf{b} \getsdollar \textsf{getEnroll}^{\mathcal{O}_{\mathcal{B}}}()$ and outputs $\mathbf{c_x} \gets \textsf{Enroll}(\textsf{esk}^\prime, \mathbf{b})$.

		\item If $b = 1$: It samples a biometric distribution $\mathcal{B}_i \getsdollar \mathbb{B}$ and an enrollment template $\mathbf{b}_i \getsdollar \textsf{getEnroll}^{\mathcal{O}_{\mathcal{B}_i}}()$, stores $\mathcal{B}_i$ in $\mathcal{T}[i]$, and outputs $\mathbf{c_x}_i \gets \textsf{Enroll}(\textsf{esk}^\prime, \mathbf{b}_i)$.
	\end{itemize}

	\item $\mathcal{O}_{\textsf{auth}}^\prime(i, \textsf{psk}^\prime)$: This oracle has access to the table $\mathcal{T}$ and behaves depending on $b$:
	\begin{itemize}
		\item If $b = 0$: It samples a probe template $\mathbf{b} \getsdollar \textsf{getProbe}^{\mathcal{O}_{\mathcal{B}}}()$ and outputs $\mathbf{c_y} \gets \textsf{Probe}(\textsf{psk}^\prime, \mathbf{b})$.

		\item If $b = 1$: Let $\mathcal{B}_i \gets \mathcal{T}[i]$. It samples a probe template $\mathbf{b}_i \getsdollar \textsf{getProbe}^{\mathcal{O}_{\mathcal{B}_i}} ()$ and outputs $\mathbf{c_y}_i \gets \textsf{Probe}(\textsf{psk}^\prime, \mathbf{b}_i)$.
	\end{itemize}
	
\end{itemize}

We forbid the adversary to query $\mathcal{O}_{\textsf{Reg}}^\prime$ on the same $\textsf{esk}^\prime$ twice to avoid trivial attacks. Without this restriction, the adversary can generate honest key triplet $(\textsf{esk}, \textsf{psk}, \textsf{csk})$, ask for two records $\mathbf{c_x}_1, \mathbf{c_x}_2$ both corresponding to $\textsf{esk}$, and use $\mathbf{c_y} \gets \mathcal{O}_{\textsf{auth}}^\prime(1, \textsf{psk})$ and $s \gets \textsf{Compare}(\textsf{csk}, \mathbf{c_x}_2, \mathbf{c_y})$ to know the challenge bit $b$. If $b = 0$, $\textsf{Verify}(s) \to 1$ with probability $\textsf{TP}$; otherwise, $\textsf{Verify}(s) \to 1$ with probability $\textsf{FP}$.

%-------------------

\newpage

%-------------------


\iffalse

\section{Achievability of $\mathcal{O}^\prime_{\textsf{Enc}}$-RUF Security}

\begin{assumption}
\label{assump:random_key_ct}

Let $\textsf{FE}$ be an fh-IPFE scheme and $(\textsf{msk}, \textsf{pp}) \gets \textsf{FE.Setup}(1^\lambda)$. Assume that given $\textsf{pp}$, there exist PPT algorithms $\textsf{RandKeyGen}$ and $\textsf{RandEnc}$ that can generate $\textsf{FE.KeyGen}(\textsf{msk}, \mathbf{r})$ and $\textsf{FE.Enc}(\textsf{msk}, \mathbf{r})$ for some random vector $\mathbf{r} \in \mathbb{F}^k$, respectively.

\end{assumption}

Note that constructions in \cite{10.1007/978-3-319-45871-7_24, cryptoeprint:2016/440} satisfy Assumption \ref{assump:random_key_ct}.

\begin{theorem}
\label{thm:fh-IPFE:ind-OEnc-ruf}
Given Assumption \ref{assump:random_key_ct}. If \textsf{FE} is fh-IND and $\emptyset$-RUF, then $\textsf{FE}$ is also $\mathcal{O}^\prime_{\textsf{Enc}}$-RUF.

\end{theorem}

\begin{proof}

Given an adversary $\mathcal{A}$ in the $\textsf{RUF}^{\mathcal{O}^\prime_{\textsf{Enc}}}_{\textsf{FE}}$ game, consider the reduction adversary $\mathcal{R}$ in Algorithm \ref{alg:red:ind-OEnc-ruf} which plays the \textsf{fh-IND} game. $\mathcal{R}$ simulates $\mathcal{O}_\textsf{Enc}^\prime(\mathbf{y}^\prime)$ by first sampling a $\mathbf{r}^\prime \gets \mathbb{F}^k$ and returning $\mathcal{O}_\textsf{Enc}(\mathbf{y}^\prime, \mathbf{r}^\prime)$.

\begin{figure}[h]
\centering

	\begin{minipage}{0.4\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\mathcal{R}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}}(\textsf{pp})$}
	\label{alg:red:ind-OEnc-ruf}
	\begin{algorithmic}[1]
		\State $\mathbf{c} \gets \textsf{RandKeyGen}(\textsf{pp})$. 

		\State ${\mathbf{\tilde{z}}} \gets {\mathcal{A}}^{\mathcal{O}^\prime_{\textsf{Enc}}} (\textsf{pp}, \mathbf{c})$

		\State $s \gets \textsf{FE.Dec}( \textsf{pp}, \mathbf{c}, \mathbf{\tilde{z}} )$
		
		\If{$ s \neq \bot$}
			\State \Return $\tilde{b} = 0$
		\Else
			\State \Return $\tilde{b} = 1$
		\EndIf

	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	\hspace{0.05\textwidth}
	\begin{minipage}{0.4\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\mathcal{A}^\prime (\textsf{pp})$}
	\label{alg:adv:ind-OEnc-ruf}
	\begin{algorithmic}[1]
		\State $\mathbf{c} \gets \textsf{RandKeyGen}(\textsf{pp})$. 

		\State ${\mathbf{\tilde{z}}} \gets {\mathcal{A}}^{\mathcal{O}^\prime_{\textsf{Enc}}} (\textsf{pp}, \mathbf{c})$

		\State \Return $\mathbf{\tilde{z}}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\end{figure}

By Assumption \ref{assump:random_key_ct}, $\mathbf{c}$ looks like an honest key of some random vector $\mathbf{r}$. If the challenge bit $b = 0$, $\mathcal{R}$ perfectly simulates an $\textsf{RUF}^{\mathcal{O}^\prime_{\textsf{Enc}}}_{\textsf{FE}}$ game for $\mathcal{A}$ and $\Pr[\tilde{b} = 0 \mid b = 0] = \Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{Enc}}}_{\textsf{FE}}(\mathcal{A}) \to 1 ]$. On the other hand, if the challenge bit $b = 1$, then $\mathcal{R}$ simulates an $\textsf{RUF}^{\emptyset}_{\textsf{FE}}$ adversary $\mathcal{A}^\prime$ in Algorithm \ref{alg:adv:ind-OEnc-ruf}. $\mathcal{A}^\prime$ runs $\mathcal{A}$ and simulates $\mathcal{O}^\prime_{\textsf{Enc}}(\mathbf{y}^\prime)$ by simply returning $\textsf{RandEnc}(\textsf{pp})$. Therefore, $\Pr[\tilde{b} = 0 \mid b = 1] = \Pr[ \textsf{RUF}^{\emptyset}_{\textsf{FE}}(\mathcal{A}^\prime) \to 1 ]$.

In conclusion,
\begin{align*}
	\Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] 
	&= \Pr[b = 0] \cdot \Pr[\tilde{b} = 0 \mid b = 0] + \Pr[b = 1] \cdot \Pr[\tilde{b} = 1 \mid b = 1] \\
	&= \frac{1}{2} \left( \Pr[\textsf{RUF}^{\mathcal{O}^\prime_{\textsf{Enc}}}_{\textsf{FE}}(\mathcal{A}) \to 1] + 1 - \Pr[ \textsf{RUF}^{\emptyset}_{\textsf{FE}}(\mathcal{A}^\prime) \to 1 ] \right) \\
	&= \frac{1}{2} + \frac{1}{2} \left( \Pr[\textsf{RUF}^{\mathcal{O}^\prime_{\textsf{Enc}}}_{\textsf{FE}}(\mathcal{A}) \to 1] - \Pr[ \textsf{RUF}^{\emptyset}_{\textsf{FE}}(\mathcal{A}^\prime) \to 1 ] \right)
\end{align*}

Since $\Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} = \left| \Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] - \frac{1}{2} \right|$ and $\Adv_{\textsf{FE}, \mathcal{A}^\prime }^{\textsf{RUF}, \emptyset} = \Pr[\textsf{RUF}^{\emptyset}_{\textsf{FE}}(\mathcal{A}^\prime) \to 1 ]$ is negligible,
\[
	\Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{Enc}}}(\mathcal{A}) \to 1]  = 2 \cdot \Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} + \Adv_{\textsf{FE}, \mathcal{A}^\prime }^{\textsf{RUF}, \emptyset} = \negl.
\]

\end{proof}

With a similar proof, one can also show that

\begin{theorem}
\label{thm:fh-IPFE:ind-OEnc-gamma-ruf}
Given Assumption \ref{assump:random_key_ct}. If \textsf{FE} is fh-IND and $\{ \emptyset, \gamma \}$-RUF, then $\textsf{FE}$ is also $\{ \mathcal{O}^\prime_{\textsf{Enc}}, \gamma \}$-RUF.

\end{theorem}

Since $\{ \mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma \}$-RUF implies $\{ \emptyset, \gamma \}$-RUF, with Theorem \ref{thm:fh-IPFE:ind-OKeyGen-gamma-ruf}, we have the following corollary.

\begin{corollary}
\label{cor:fh-IPFE:ind-OKeyGen-OEnc-ruf}
Given Assumption \ref{assump:only-return-valid-ct} and \ref{assump:random_key_ct}. If \textsf{FE} is fh-IND, then $\textsf{FE}$ is both $\{ \mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma \}$-RUF and $\{ \mathcal{O}^\prime_{\textsf{Enc}}, \gamma \}$-RUF for any $\gamma \leq (1 - \frac{1}{\poly}) \cdot \|\mathbb{F}\|$.
\end{corollary}


%-------------------

\newpage

%-------------------

\section{Instantiation using Other Primitives}

\begin{itemize}
	\item Homomorphic encryption (HE) \cite{10.1007/978-3-642-01957-9_7, 10.1007/978-3-642-40588-4_5, pradel2021privacypreservingbiometricmatchingusing}:
	\begin{itemize}
		\item \cite{10.1007/978-3-642-40588-4_5}: The server owns the secret key for the HE. $\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{c_y})$ is split into two phases:
			\begin{itemize}
				\item With $\mathbf{c_x}$ and $\mathbf{c_y}$, homomorphically compute the encryption of $\textsf{HW}(\mathbf{b} \oplus \mathbf{b}^\prime)$.
				\item Use $\textsf{csk}$, which is the secret key of the HE, to recover $\textsf{HW}(\mathbf{b} \oplus \mathbf{b}^\prime)$.
			\end{itemize}
			If we want to hide the biometrics $\mathbf{b}, \mathbf{b}^\prime$ from the server, two phases of $\textsf{Compare}$ have to be run by two parties.
			\begin{itemize}
				\item The first one only has $\mathbf{c_x}$ without $\textsf{csk}$.
				\item The other one only has $\textsf{csk}$ without $\mathbf{c_x}$.
			\end{itemize}
		\item \cite{10.1007/978-3-642-01957-9_7, pradel2021privacypreservingbiometricmatchingusing}: The user owns the secret key for the HE. The server homomorphically computes the encryption of $\textsf{HW}(\mathbf{b} \oplus \mathbf{b}^\prime) + R$, where $R$ is a random value, and sends it to the user. The user decrypts the value $\textsf{HW}(\mathbf{b} \oplus \mathbf{b}^\prime) + R$, sends it back to the server. The server recovers $\textsf{HW}(\mathbf{b} \oplus \mathbf{b}^\prime)$ by subtracting from $R$.

	\end{itemize}

	\item Fuzzy extractor \cite{10.1145/1030083.1030096, 7980010}: This requires either the enrollment phase passes a public string $Q$ to the authentication phase, or the server sends $Q$ to the user on authentication.

	\item Oblivious transfer \cite{cryptoeprint:2012/586}: The server knows $\mathbf{b}$. Run $k$ OT protocols, where $k$ is the length of $\mathbf{b}$ and $\mathbf{b}^\prime$. At the end, the user will have some random value $R$. The server will have $T = \textsf{HW}(\mathbf{b} \oplus \mathbf{b}^\prime) + R$. The user sends $R$ to the server, and the server recovers $\textsf{HW}(\mathbf{b} \oplus \mathbf{b}^\prime) = T - R$.

\end{itemize}

\fi

%-------------------

\newpage

%-------------------

%-------------------
%% Backup File

% \input{backup.tex}

%-------------------
%% Reference List
\pagebreak

\nocite{*}
\printbibliography


\end{document}
