%%%%%%%%%%%%%%%%%%%%

% Project Name: Semester Project Fall 2024 for EPFL
% File: main.tex
% Author: Keng-Yu Chen

%%%%%%%%%%%%%%%%%%%%

\input{header.tex}


\begin{document}

%% Title
\title{\textbf{The Cryptographic Layer of Biometric Authentication}}
\author{Keng-Yu Chen \\
  \multicolumn{1}{p{.7\textwidth}}{} \\
  \multicolumn{1}{p{.7\textwidth}}{\centering \textbf{Supervisor}: Serge Vaudenay}\\
  \multicolumn{1}{p{.7\textwidth}}{\centering LASEC, EPFL}\\
  \\
}
\date{\today}

\maketitle

%-------------------

%% Header and Foot
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{LASEC}
\fancyhead[R]{Keng-Yu Chen}
\fancyfoot[C]{\thepage}

%-------------------
% Abstract
\input{Contents/abstract}

%-------------------
% Introduction
\section{Introduction}
\label{sec:introdiction}
\input{Contents/introduction.tex}

%-------------------
% Fomalization
\section{Formalization}
\label{sec:formalization}
\input{Contents/formalization.tex}

%-------------------
% Security Games
\section{Security Games}
\label{sec:security_game}
\input{Contents/security_game.tex}

%-------------------
% Security Analysis: fh-IPFE-based Instantiation
\section{Security Analysis: fh-IPFE-based Instantiation}
\label{sec:security_analysis:fh-IPFE}
\input{Contents/security_analysis_fh-IPFE.tex}

%-------------------
% Security Analysis: Relational Hash-based Instantiation
\section{Security Analysis: Relational Hash-based Instantiation}
\label{sec:security_analysis:rh}
\input{Contents/security_analysis_rh.tex}

%-------------------

\newpage
\appendix

%-------------------

\section{Construction in \cite{cryptoeprint:2016/440}}
\label{sec:fh-IPFE-construction}

Let $\mathbb{G}_1$ and $\mathbb{G}_2$ be two groups of order a prime number $q$ with generators $g_1$ and $g_2$, respectively. Let $e: \mathbb{G}_1 \times \mathbb{G}_2 \to \mathbb{G}_T$ be a mapping to a target group $\mathbb{G}_T$ also of order $q$. 

\begin{definition}[Bilinear asymmetric group \cite{cryptoeprint:2016/440}]
\label{bilinear-group}

A tuple $(\mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T, q, e)$ is a \emph{bilinear asymmetric group} if the following hold.

\begin{itemize}

	\item Group operations in $\mathbb{G}_1, \mathbb{G}_2$, and $\mathbb{G}_T$ and mapping $e$ are efficiently computable.

	\item $e$ is bilinear. That is, for $x, y \in \Z_q$, $e(g_1^x, g_2^y) = e(g_1, g_2)^{xy}$.

	\item $e$ is non-degenerate. That is, $e(g_1, g_2) \neq 1$, the identity element of $\mathbb{G}_T$.

\end{itemize}

\end{definition}

For a vector $\mathbf{v} = (v_1, v_2, \cdots, v_n) \in \Z_q^n$ and a group element $g$ in group of order $q$, we write $g^\mathbf{v}$ to denote the vector of group elements $(g^{v_1}, g^{v_2}, \cdots, g^{v_n})$. Moreover, for $k \in \Z_q$ and $\mathbf{v}, \mathbf{w} \in \Z_q^n$, we write $(g^{\mathbf{v}})^k = g^{k \cdot \mathbf{v}}$ and $g^\mathbf{v} \cdot g^\mathbf{w} =  g^{\mathbf{v} + \mathbf{w}}$. Finally, the pairing operation is extended to vectors.
\[
	e(g_1^{\mathbf{v}}, g_2^{\mathbf{w}}) = \prod_{i \in [n]} e(g_1^{v_i}, g_2^{w_i}) = e(g_1, g_2)^{\mathbf{v}\mathbf{w}^T}.
\]

We now recall the fh-IPFE construction $\textsf{FE}$ in \cite{cryptoeprint:2016/440}.

\begin{itemize}

	\item $\textsf{FE.Setup}(1^\lambda)$: Sample an asymmetric bilinear group $(\mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T, q, e)$ and choose generators $g_1 \in \mathbb{G}_1$ and $g_2 \in \mathbb{G}_2$. Sample $\mathbf{B} \in \mathbb{GL}_n(\Z_q)$ and find $\mathbf{B}^* = \det(\mathbf{B}) \cdot (\mathbf{B}^{-1})^T$. Finally, output the public parameter $\textsf{pp} = (\mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T, q, e)$ and the master secret key $\textsf{msk} = (\textsf{pp}, g_1, g_2, \mathbf{B}, \mathbf{B}^*)$.
	
	\item $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x})$: Sample $\alpha \getsdollar \Z_q$ and output
	\[
		 f_\mathbf{x} = (K_1, K_2) = \left( g_1^{\alpha \cdot \det(\mathbf{B})}, g_1^{\alpha \cdot \mathbf{x} \cdot \mathbf{B}} \right)
	\]
	
	\item $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y})$: Sample $\beta \getsdollar \Z_q$ and output
	\[
		 \mathbf{c_y} = (C_1, C_2) = \left( g_2^{\beta}, g_2^{\beta \cdot \mathbf{y} \cdot \mathbf{B}^*} \right)
	\]
	
	\item $\textsf{FE.Dec}(\textsf{pp}, f_\mathbf{x}, \mathbf{c_y}) \to z$: Parse $f_\mathbf{x} = (K_1, K_2)$ and $\mathbf{c_y} = (C_1, C_2)$ and compute 
	\[
		D_1 = e(K_1, C_1) \quad \text{and} \quad D_2 = e(K_2, C_2)
	\]
	Solve the discrete logarithm to find $z$ such that $D_1^z = D_2$ and output $z$. If it fails to find such $z$, output $\bot$.

\end{itemize}

\paragraph{Correctness}
We have
\[
	D_1 = e(K_1, C_1) = e(g_1, g_2)^{\alpha \cdot \beta \cdot \det(\mathbf{B})}
\] and 
\[
	D_2 = e(K_2, C_2) = e(g_1, g_2)^{\alpha \cdot \beta \cdot \mathbf{x} \cdot \mathbf{B} \cdot (\mathbf{B}^*)^T \cdot \mathbf{y}^T \cdot } = e(g_1, g_2)^{\alpha \cdot \beta \cdot \det(\mathbf{B}) \cdot \mathbf{x}\mathbf{y}^T }.
\]
Therefore, $(D_1)^{\mathbf{x}\mathbf{y}^T} = D_2$.

\paragraph{Remark}
In this construction, $q$ is exponential to $\lambda$ to achieve security, and decryption relies on some priori knowledge of possible ranges of the inner product $\mathbf{x} \mathbf{y}^T$. For example, for the instantiation in Section \ref{sec:fh-IPFE-instantiation}, one can enumerate $z \in \{0, 1, \cdots, \tau \}$ and return $\bot$ when no valid $z \leq \tau$ such that $D_1^z = D_2$ is found.

%-------------------

\newpage

%-------------------

\section{$\gamma$-RUF Security of \textsf{FE}}

Let $\mathbb{F} = \Z_q$. We can extend the definition of the RUF security in Section \ref{sec:security_analysis:fh-IPFE:ruf} with an integer parameter $\gamma$.

\begin{figure}[H]
\centering

	\begin{minipage}[t]{0.55\textwidth}
	\begin{algorithm}[H]
	\caption{$\textsf{RUF}^{\mathcal{O}, \gamma}_{\textsf{FE}}(\mathcal{A})$}
	\label{alg:gamma-ruf-fh-IPFE}
	\begin{algorithmic}[1]
		\State $\mathbf{r} \getsdollar \mathbb{F}^{k}$

		\State $\textsf{msk}, \textsf{pp} \gets \textsf{FE.Setup}(1^\lambda)$

		\State $\mathbf{c} \gets \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{r})$

		\State $\mathbf{\tilde{z}} \gets \mathcal{A}^{\mathcal{O}} ( \textsf{pp}, \mathbf{c} )$

		\If{$\mathbf{\tilde{z}}$ is equal to any output of $\mathcal{O}^\prime_{\textsf{Enc}}$ }
			
			\State \Return $0$
		
		\EndIf

		\State $s \gets \textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{\tilde{z}} )$

		\State \Return $1_{s \leq \gamma}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\end{figure}

Here, the game runs $1_{s \leq \gamma}$ by first viewing the field element $s \in \Z_q$ as a positive integer in $\{0, 1, \cdots, q-1 \}$ and comparing it with $\gamma$.

The oracle $\mathcal{O}$ can be nothing or include $\mathcal{O}^\prime_{\textsf{KeyGen}}(\cdot)$ and $\mathcal{O}^\prime_{\textsf{Enc}}(\cdot)$ based on the threat model as in Section \ref{sec:security_analysis:fh-IPFE:ruf}.

\begin{definition}[$\gamma$-RUF Security]

	An fh-IPFE scheme \textsf{FE} is called $\{ \mathcal{O}, \gamma \}$-RUF secure if for any adversary $\mathcal{A}$, the advantage of $\mathcal{A}$ in the $\textsf{RUF}^{\mathcal{O}, \gamma}_\textsf{FE}$ game in Algorithm \ref{alg:gamma-ruf-fh-IPFE} is
\[
	\Adv_{\textsf{FE}, \mathcal{A}}^{\textsf{RUF}, \mathcal{O}, \gamma} := \Pr[\textsf{RUF}^{\mathcal{O}, \gamma}_{\textsf{FE}}(\mathcal{A}) \to 1 ] = \negl.
\]

\noindent Note that if $\textsf{FE}$ is $\mathcal{O}$-RUF secure, it is $\{ \mathcal{O}, \gamma \}$-RUF secure for any integer $\gamma$.
\end{definition}

With the extension with $\gamma$, we can rewrite our results in Section \ref{sec:security_analysis:fh-IPFE}.


\begin{theorem}[Theorem \ref{thm:fh-IPFE:ind-ruf-OB-Enroll}]
\label{thm:fh-IPFE:ind-gamma-ruf-OB-Enroll}
	Let $\textsf{option} = \{ \textsf{csk}, \mathbf{c_x}, \mathcal{O}_\mathcal{B}, \mathcal{O}_{\textsf{Enroll}} \}$. For any distribution family $\mathbb{B}$, if \textsf{FE} is fh-IND and $\{ \mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma \}$-RUF for a $\gamma \geq \tau^2$, then $\Pi$ is $\textsf{option}$-UF. 
\end{theorem}

\begin{theorem}[Theorem \ref{thm:fh-IPFE:ind-ruf-OB-Probe}]
\label{thm:fh-IPFE:ind-gamma-ruf-OB-Probe}
	Let $\textsf{option} = \{\textsf{csk}, \mathbf{c_x}, \mathcal{O}_\mathcal{B}, \mathcal{O}_\textsf{Probe}\}$. For any distribution family $\mathbb{B}$, if \textsf{FE} is fh-IND and $\{ \mathcal{O}^\prime_{\textsf{Enc}}, \gamma \}$-RUF for a $\gamma \geq \tau^2$, then $\Pi$ is $\textsf{option}$-UF. 
\end{theorem}

\subsection{Achievability of $\gamma$-RUF Security}

\begin{assumption}
\label{assump:only-return-valid-ct}
Assume that $\textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{z})$ only returns when $\mathbf{z}$ corresponds to a \emph{nonzero} vector $\mathbf{v} \in \mathbb{F}^k$. More precisely, assume that for any $\mathbf{z}$, there can only be two possibilities.

\begin{itemize}
	\item Either there exists a vector $\mathbf{v} \in \mathbb{F}^k \setminus \{\mathbf{0}\}$ such that for any $\mathbf{x} \in \mathbb{F}^k, \mathbf{c} \gets \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x})$, 
	\[
		%\textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{z}) = \textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{c_v}).
		\textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{z}) = \mathbf{x}\mathbf{v}^T.
	\]
	\item Or for any $\mathbf{x} \in \mathbb{F}^k$ and $ \mathbf{c} \gets \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x})$, $\textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{z}) \to \bot$.

\end{itemize}
Note that this implies $\textsf{FE}$ rejects zero vector $\mathbf{0}$ as the input of $\textsf{FE.Enc}$.
\end{assumption}

\begin{theorem}
\label{thm:fh-IPFE:ind-OKeyGen-gamma-ruf}
Given Assumption \ref{assump:only-return-valid-ct}. If \textsf{FE} is fh-IND, then $\textsf{FE}$ is $\{ \mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma \}$-RUF for any $\gamma \leq (1 - \frac{1}{\poly}) \cdot \|\mathbb{F}\|$.

\end{theorem}

\begin{proof}
Given an adversary $\mathcal{A}$ in the $\textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}_{\textsf{FE}}$ game for a $\gamma \leq (1 - \frac{1}{P(\lambda)}) \cdot \|\mathbb{F}\|$, where $P(\lambda)$ is any polynomial. Let $t$ be an integer, consider the reduction adversary $\mathcal{R}$ in Algorithm \ref{alg:red:ind-OKeyGen-gamma-ruf} which plays the \textsf{fh-IND} game. $\mathcal{R}$ simulates $\mathcal{O}_\textsf{KeyGen}^\prime(\mathbf{x}^\prime)$ by $\mathcal{O}_\textsf{KeyGen}(\mathbf{x}^\prime, \mathbf{x}^\prime)$.
If there exists an $s_i \neq \bot$ in Line \ref{alg:red:ind-OKeyGen-gamma-ruf:s}, by Assumption \ref{assump:only-return-valid-ct}, let $\mathbf{\tilde{z}}$ correspond to a nonzero vector $\mathbf{\tilde{v}}$.

\begin{figure}[h]
\centering
	
	\begin{minipage}[t]{0.5\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\mathcal{R}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}}(\textsf{pp})$}
	\label{alg:red:ind-OKeyGen-gamma-ruf}
	\begin{algorithmic}[1]
		\State $\mathbf{r}^{(0)}, \mathbf{r}^{(1)} \getsdollar \mathbb{F}^{k}$
		
		\State $\mathbf{c} \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{r}^{(0)}, \mathbf{r}^{(1)})$ 

		\State ${\mathbf{\tilde{z}}} \gets {\mathcal{A}}^{\mathcal{O}^\prime_{\textsf{KeyGen}}} (\textsf{pp}, \mathbf{c})$

		\For{$i = 1$ to $t$}
		
			\State $\mathbf{r}_i \getsdollar \mathbb{F}^{k}$

			\State $\mathbf{c}_i \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{r}^{(0)}, \mathbf{r}_i)$

			\State $s_i \gets \textsf{FE.Dec}( \textsf{pp}, \mathbf{c}_i, \mathbf{\tilde{z}} )$ \label{alg:red:ind-OKeyGen-gamma-ruf:s}
	
		\EndFor	
		
		\If{$\bigwedge_{i=1}^t s_i \leq \gamma$} \label{alg:red:ind-OKeyGen-gamma-ruf:verify}
			\State \Return $\tilde{b} = 0$
		\Else
			\State \Return $\tilde{b} \getsdollar \{0, 1\}$
		\EndIf

	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\end{figure}


If the challenge bit $b = 0$, then by Assumption \ref{assump:only-return-valid-ct}, any $s_i \neq \bot$ in Line \ref{alg:red:ind-OKeyGen-gamma-ruf:s} implies all $s_i \neq \bot$ and $s_i = s_j$ for any $i, j$. Therefore, the probability that all $s_i \leq \gamma$ in Line \ref{alg:red:ind-OKeyGen-gamma-ruf:verify} is
\begin{align*}
	\Pr\left[ \bigwedge_{i=1}^t s_i \leq \gamma \mid b = 0 \right]
	&= \Pr\left[ s_1 \neq \bot \mid b = 0 \right] \cdot \Pr \left[ s_1 \leq \gamma \mid b = 0 \wedge s_1 \neq \bot \right] \\
	&= \Pr \left[ s_1 \neq \bot \mid b = 0 \right] \cdot \Pr \left[ \mathbf{r}^{(0)} \mathbf{\tilde{v}}^T \leq \gamma \mid b = 0 \wedge s_1 \neq \bot \right] \\
	&= \Pr \left[s_1 \neq \bot \mid b = 0 \right] \cdot \Pr \left[ \textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{\tilde{z}}) \leq \gamma \mid b = 0 \wedge s_1 \neq \bot \right] \\
	&= \Pr \left[s_1 \neq \bot \mid b = 0 \right] \cdot \Pr \left[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1 \mid b = 0 \wedge s_1 \neq \bot \right] \\ 
	&= \Pr \left[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1 \right] 
\end{align*}

If the challenge bit $b = 1$, for any $i \in [t]$,
\begin{align*}
	\Pr[ s_i \leq \gamma \mid b = 1 ]
	&= \Pr[s_i \neq \bot \mid b = 1] \cdot \Pr[ s_i \leq \gamma \mid b = 1 \wedge s_i \neq \bot] \\
	&= \Pr[s_i \neq \bot \mid b = 1] \cdot \Pr[ \mathbf{r}_i \mathbf{\tilde{v}}^T \leq \gamma \mid b = 1 \wedge s \neq \bot]
\end{align*}
Note that $\mathbf{r}_i$ is independent of $\mathbf{\tilde{z}}$ and thus independent of $\mathbf{\tilde{v}}$. Hence, $\Pr[\mathbf{r}_i \mathbf{\tilde{v}}^T \leq \gamma \mid b = 1 \wedge s_i \neq \bot] = \frac{\gamma}{\| \mathbb{F} \|}$ and
\[
	\Pr \left[ \bigwedge_{i=1}^t s_i \leq \gamma \mid b = 1 \right] = \Pr \left[ \bigwedge_{i=1}^t s_i \neq \bot \mid b = 1 \right] \cdot \left( \frac{\gamma}{\| \mathbb{F} \|} \right)^t \leq \left( \frac{\gamma}{\| \mathbb{F} \|} \right)^t
\]

In conclusion,
\begin{align*}
	\Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] 
	&= \frac{1}{2} + \frac{1}{4} \left( \Pr \left[ \bigwedge_{i=1}^t s_i \leq \gamma \mid b = 0 \right] - \Pr \left[ \bigwedge_{i=1}^t s_i \leq \gamma \mid b = 1 \right] \right) \\
	&\geq \frac{1}{2} + \frac{1}{4} \left( \Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1] - \left( \frac{\gamma}{\| \mathbb{F} \|} \right)^t \right) \\
	&\geq \frac{1}{2} + \frac{1}{4} \left( \Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1] -  e^{- t \cdot (1 - \frac{\gamma}{\| \mathbb{F} \|}) } \right) \\
	&\geq \frac{1}{2} + \frac{1}{4} \left( \Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1] -  e^{- \frac{t}{P(\lambda)} } \right)
\end{align*}

\noindent Take $t$ be any integer larger than $P(\lambda) \cdot \lambda$. Since $\Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} = \left| \Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] - \frac{1}{2} \right|$ and $e^{-t \cdot \frac{1}{P(\lambda)}} < e^{-\lambda}$ are negligible,
\[
	\Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1]  \leq e^{- \frac{t}{P(\lambda)} } + 4 \cdot \Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND}  = \negl.
\]

\end{proof}

%-------------------

\newpage

%-------------------


%\iffalse

\section{Fixing the Proof of Theorem \ref{thm:fh-IPFE:ind-ruf-OB-Probe}}

In Theorem \ref{thm:fh-IPFE:ind-ruf-OB-Probe}, we simulate the oracle $\mathcal{O}_{\textsf{Probe}}$ in the adversary $\mathcal{A}^\prime$ in Algorithm \ref{alg:adv:ind-uf-OB-Probe} in the $\textsf{RUF}^{ \mathcal{O}^\prime_{\textsf{Enc}} }$ game by the following steps:

\begin{enumerate}

\item Sample $k+2$ independent vectors $\mathbf{e}^{(1)}, \cdots, \mathbf{e}^{(k+2)}$.

\item For $i \in [k+2]$, $\mathbf{c}^{(i)} \gets \mathcal{O}^\prime_{\textsf{Enc}}(\mathbf{e}^{(i)})$.

\item For $i \in [k+2]$,  $d_i \gets \textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{c}^{(i)})$, where $\mathbf{c}$ is $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{r})$.

\item Find the vector $\mathbf{r}$ by solving the linear system $\{ \mathbf{r} {\mathbf{e}^{(i)}}^T = d_i \}_{i=1}^{k+2}$.

\item On query $\mathcal{O}_{\textsf{Probe}}(\mathbf{b}^\prime)$, first encode $\mathbf{b}^\prime$ into $\mathbf{y}^\prime$ and find $d \gets \mathbf{x}^{*}{\mathbf{y}^\prime}^T$. Then find a vector $\mathbf{y}^{\prime\prime}$ such that $\mathbf{r} {\mathbf{y}^{\prime\prime}}^T = d$. Return $\mathcal{O}^\prime_{\textsf{Enc}}(\mathbf{y}^{\prime\prime})$.

\end{enumerate}

However, $\textsf{FE.Dec}$ of constructions in \cite{cryptoeprint:2015/1255, 10.1007/978-3-319-45871-7_24, cryptoeprint:2016/440} rely on some \emph{prior knowledge} of the inner product. Their basic idea is to find $d$ given $g$ and $g^d$, where $g$ is in a group of exponential size. Therefore, $\textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{c}^{(i)})$ will probably return $\bot$, representing that $d$ is too large to find.

For this problem, I have three proposals:
\begin{enumerate}
	\item Let the adversary choose $\mathbf{r}$.

	\item Modify the $\textsf{RUF}$ game. 

	\item Do nothing. Claim \cite{cryptoeprint:2015/1255, 10.1007/978-3-319-45871-7_24, cryptoeprint:2016/440} are not ideal \textsf{FE}.
\end{enumerate}

\subsection{Solution I}
Consider the \textsf{SUF} game.
\begin{figure}[H]
\centering

	\begin{minipage}[t]{0.55\textwidth}
	\begin{algorithm}[H]
	\caption{$\textsf{SUF}^{\mathcal{O}}_{\textsf{FE}}(\mathcal{A} = (\mathcal{A}_1, \mathcal{A}_2))$}
	\begin{algorithmic}[1]
		\State $\mathbf{r}, \textsf{st} \gets \mathcal{A}_1(1^\lambda)$

		\If{$\mathbf{r} = \mathbf{0}$}
			\State \Return $\bot$
		\EndIf

		\State $\textsf{msk}, \textsf{pp} \gets \textsf{FE.Setup}(1^\lambda)$

		\State $\mathbf{c} \gets \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{r})$

		\State $\mathbf{\tilde{z}} \gets \mathcal{A}_2^{\mathcal{O}} ( \textsf{st}, \textsf{pp}, \mathbf{c} )$

		\If{$\mathbf{\tilde{z}}$ is equal to any output of $\mathcal{O}^\prime_{\textsf{Enc}}$ }
			
			\State \Return $0$
		
		\EndIf

		\State $s \gets \textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{\tilde{z}} )$

		\State \Return $1_{s \neq \bot}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\end{figure}

$\mathbf{r} \neq 0$ is because for constructions \cite{10.1007/978-3-319-45871-7_24, cryptoeprint:2016/440}, there exists an algorithm $\textsf{RandEnc}(\textsf{pp})$ that can generate ciphertexts of random unknown vectors $\textsf{FE.Enc}(\textsf{msk}, r)$.

I call this security property \emph{selective unforgeability (SUF)}. An SUF \textsf{FE} is RUF since the adversary $\mathcal{A}_1$ can choose $\mathbf{r} \getsdollar \mathbb{F}^k$. We can also add a signature scheme to an \textsf{FE} to make it SUF. Moreover, if we use SUF security, we do not need fh-IND security in our main results in \ref{sec:security_analysis:fh-IPFE:uf}. One can reduce \textsf{option}-\textsf{UF} of $\Pi$ to \textsf{SUF} of $\textsf{FE}$ in a simple and intuitive way.

\begin{theorem}
	Let $\textsf{option} = \{ \mathbf{c_x}, \textsf{csk}, \mathcal{O}_\mathcal{B}, \mathcal{O}_{\textsf{Enroll}} \}$. For any distribution family $\mathbb{B}$, if either one of the following is satisfied:
	\begin{itemize}
		\item \textsf{FE} is both fh-IND and $\mathcal{O}^\prime_{\textsf{KeyGen}}$-RUF (Theorem \ref{thm:fh-IPFE:ind-ruf-OB-Enroll})
		\item \textsf{FE} is $\mathcal{O}^\prime_{\textsf{KeyGen}}$-SUF
	\end{itemize}
then $\Pi$ is $\textsf{option}$-UF. 
\end{theorem}

\begin{theorem}
	Let $\textsf{option} = \{ \mathbf{c_x}, \textsf{csk}, \mathcal{O}_\mathcal{B}, \mathcal{O}_{\textsf{Probe}} \}$. For any distribution family $\mathbb{B}$, if \textsf{FE} is $\mathcal{O}^\prime_{\textsf{Enc}}$-SUF, then $\Pi$ is $\textsf{option}$-UF. 
\end{theorem}

We can also leave both \textsf{RUF} and \textsf{SUF} security.

\subsection{Solution II}

Instead of sampling $\mathbf{r} \getsdollar \mathbb{F}^{k}$, one samples $\mathbf{r} \getsdollar \{0, 1\}^{k+2}$.
\begin{enumerate}

	\item Pick $k+2$ random one-hot vectors $\mathbf{e}^{(i)} \gets (0, \cdots, \overset{i\text{th}}{u_i}, \cdots, 0)$, where $u \getsdollar \mathbb{F}$.

	\item For $i \in [k+2]$, $\mathbf{c}^{(i)} \gets \mathcal{O}^\prime_{\textsf{Enc}}(\mathbf{e}^{(i)})$.

	\item For $i \in [k+2]$, $d_i \gets \textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{c}^{(i)})$. Note that $d_i$ can only be $u_i$ or $0$.

	\item Find the vector $\mathbf{r} \in \{0, 1\}^{k+2}$.

	\item On query $\mathcal{O}_{\textsf{Probe}}(\mathbf{b}^\prime)$, first encode $\mathbf{b}^\prime$ into $\mathbf{y}^\prime$ and find $d \gets \mathbf{x}^{*}{\mathbf{y}^\prime}^T$. Then find a vector $\mathbf{y}^{\prime\prime}$ such that $\mathbf{r} {\mathbf{y}^{\prime\prime}}^T = d$. Return $\mathcal{O}^\prime_{\textsf{Enc}}(\mathbf{y}^{\prime\prime})$.

\end{enumerate}

\subsection{Solution III}

We can say these fh-IPFE constructions \cite{cryptoeprint:2015/1255, 10.1007/978-3-319-45871-7_24, cryptoeprint:2016/440} are not \emph{ideal}. Their $\textsf{FE.Dec}$ often aborts on unrestricted inputs. On the contrary, constructions like \cite{10.1007/978-3-030-90567-5_33} do not need discrete logarithm in $\textsf{FE.Dec}$. Unfortunately, it is not \textsf{fh-IND} secure.

%-------------------

\newpage

%-------------------

\section{Reusability}

The work \cite{simoens2012framework} discusses a security concept related to reusability. It is called \emph{Trace users with different identities}. It is about when a user registers multiple records of its biometrics on the database. The server or compromised database should not be able to find that two records correspond to the same person.

Based on this concept, I design the following games. $\mathcal{S}_{\textsf{Enroll}}$ and $\mathcal{S}_{\textsf{Probe}}$ are two simulators that do not have access to $\mathbb{B}$.

\begin{figure}[H]
\centering

	\begin{minipage}[t]{0.45\textwidth}
	\begin{algorithm}[H]
	\caption{$\textsf{REU}_{\Pi, \mathbb{B}}(\mathcal{A})$}
	\begin{algorithmic}[1]
		\State $b \getsdollar \{0, 1\}$

		\State $\mathcal{B} \getsdollar \mathbb{B}, \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$

		\State $\tilde{b} \gets \mathcal{A}^{\mathcal{O}_{\textsf{Reg}}, \mathcal{O}_{\textsf{auth}}}(1^\lambda)$
 
		\State \Return $1_{\tilde{b} = b}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\end{figure}

\begin{itemize}
	\item $\mathcal{O}_{\textsf{Reg}}$: It maintains a table $\mathcal{T}$ and a counter $i$ initialized to $0$ at the beginning. On query, it updates $i \gets i+1$, and behaves depending on $b$:
	\begin{itemize}
		\item If $b = 0$: It generates key triplets $(\textsf{esk}_i, \textsf{psk}_i, \textsf{csk}_i) \gets \textsf{Setup}(1^\lambda)$, samples an enrollment template $\mathbf{b} \getsdollar \textsf{getEnroll}^{\mathcal{O}_{\mathcal{B}}}()$, stores an entry $\textsf{psk}_i$ in $\mathcal{T}[i]$, and outputs $\mathbf{c_x}_i \gets \textsf{Enroll}(\textsf{esk}_i, \mathbf{b})$ and $\textsf{csk}_i$.

		\item If $b = 1$: It generates key triplets $(\textsf{esk}_i, \textsf{psk}_i, \textsf{csk}_i) \gets \textsf{Setup}(1^\lambda)$, samples a biometric distribution $\mathcal{B}_i \getsdollar \mathbb{B}$ and an enrollment template $\mathbf{b}_i \getsdollar \textsf{getEnroll}^{\mathcal{O}_{\mathcal{B}_i}}()$, stores an entry $(\textsf{psk}_i, \mathcal{B}_i)$ in $\mathcal{T}[i]$, and outputs $\mathbf{c_x}_i \gets \textsf{Enroll}(\textsf{esk}_i, \mathbf{b}_i)$ and $\textsf{csk}_i$.
	\end{itemize}

	\item $\mathcal{O}_{\textsf{auth}}(i)$: This oracle has access to the table $\mathcal{T}$. On input $i$, it retrieves the entry $\mathcal{T}[i]$ and behaves depending on $b$:
	\begin{itemize}
		\item If $b = 0$: Let $\textsf{psk}_i \gets \mathcal{T}[i]$. It samples a probe template $\mathbf{b} \getsdollar \textsf{getProbe}^{\mathcal{O}_{\mathcal{B}}}()$ and outputs $\mathbf{c_y}_i \gets \textsf{Probe}(\textsf{psk}_i, \mathbf{b})$.

		\item If $b = 1$: Let $(\textsf{psk}_i, \mathcal{B}_i) \gets \mathcal{T}[i]$. It samples a probe template $\mathbf{b}_i \getsdollar \textsf{getProbe}^{\mathcal{O}_{\mathcal{B}_i}} ()$ and outputs $\mathbf{c_y}_i \gets \textsf{Probe}(\textsf{psk}_i, \mathbf{b}_i)$.
	\end{itemize}
	
\end{itemize}
If any adversary $\mathcal{A}$ cannot recover the bit $b$; that is, if $\Pr[ \textsf{REU}(\mathcal{A}) \to 1 ] = \negl.$, then a real-world server cannot distinguish whether a list of enrollment records all corresponding to the same person or not.

To provide more power for the adversary, we can also consider the following oracles.

\begin{itemize}
	\item $\mathcal{O}_{\textsf{Reg}}^\prime(\textsf{esk}^\prime)$: This oracle maintains a table $\mathcal{T}$ and a counter $i$ initialized to $0$ at the beginning. If $\textsf{esk}^\prime$ has been queried before, it aborts. Otherwise, it updates $i \gets i+1$ and behaves depending on $b$:
	\begin{itemize}
		\item If $b = 0$: It samples an enrollment template $\mathbf{b} \getsdollar \textsf{getEnroll}^{\mathcal{O}_{\mathcal{B}}}()$ and outputs $\mathbf{c_x} \gets \textsf{Enroll}(\textsf{esk}^\prime, \mathbf{b})$.

		\item If $b = 1$: It samples a biometric distribution $\mathcal{B}_i \getsdollar \mathbb{B}$ and an enrollment template $\mathbf{b}_i \getsdollar \textsf{getEnroll}^{\mathcal{O}_{\mathcal{B}_i}}()$, stores $\mathcal{B}_i$ in $\mathcal{T}[i]$, and outputs $\mathbf{c_x}_i \gets \textsf{Enroll}(\textsf{esk}^\prime, \mathbf{b}_i)$.
	\end{itemize}

	\item $\mathcal{O}_{\textsf{auth}}^\prime(i, \textsf{psk}^\prime)$: This oracle has access to the table $\mathcal{T}$ and behaves depending on $b$:
	\begin{itemize}
		\item If $b = 0$: It samples a probe template $\mathbf{b} \getsdollar \textsf{getProbe}^{\mathcal{O}_{\mathcal{B}}}()$ and outputs $\mathbf{c_y} \gets \textsf{Probe}(\textsf{psk}^\prime, \mathbf{b})$.

		\item If $b = 1$: Let $\mathcal{B}_i \gets \mathcal{T}[i]$. It samples a probe template $\mathbf{b}_i \getsdollar \textsf{getProbe}^{\mathcal{O}_{\mathcal{B}_i}} ()$ and outputs $\mathbf{c_y}_i \gets \textsf{Probe}(\textsf{psk}^\prime, \mathbf{b}_i)$.
	\end{itemize}
	
\end{itemize}

We forbid the adversary to query $\mathcal{O}_{\textsf{Reg}}^\prime$ on the same $\textsf{esk}^\prime$ twice to avoid trivial attacks. Without this restriction, the adversary can generate honest key triplet $(\textsf{esk}, \textsf{psk}, \textsf{csk})$, ask for two records $\mathbf{c_x}_1, \mathbf{c_x}_2$ both corresponding to $\textsf{esk}$, and use $\mathbf{c_y} \gets \mathcal{O}_{\textsf{auth}}^\prime(1, \textsf{psk})$ and $s \gets \textsf{Compare}(\textsf{csk}, \mathbf{c_x}_2, \mathbf{c_y})$ to know the challenge bit $b$. If $b = 0$, $\textsf{Verify}(s) \to 1$ with probability $\textsf{TP}$; otherwise, $\textsf{Verify}(s) \to 1$ with probability $\textsf{FP}$.

%-------------------

\newpage

%-------------------

\section{Instantiation using Other Primitives}

\begin{itemize}
	\item Homomorphic encryption (HE) \cite{10.1007/978-3-642-01957-9_7, 10.1007/978-3-642-40588-4_5, pradel2021privacypreservingbiometricmatchingusing}:
	\begin{itemize}
		\item \cite{10.1007/978-3-642-40588-4_5}: The server owns the secret key for the HE. $\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{c_y})$ is split into two phases:
			\begin{itemize}
				\item With $\mathbf{c_x}$ and $\mathbf{c_y}$, homomorphically compute the encryption of $\textsf{HW}(\mathbf{b} \oplus \mathbf{b}^\prime)$.
				\item Use $\textsf{csk}$, which is the secret key of the HE, to recover $\textsf{HW}(\mathbf{b} \oplus \mathbf{b}^\prime)$.
			\end{itemize}
			If we want to hide the biometrics $\mathbf{b}, \mathbf{b}^\prime$ from the server, two phases of $\textsf{Compare}$ have to be run by two parties.
			\begin{itemize}
				\item The first one only has $\mathbf{c_x}$ without $\textsf{csk}$.
				\item The other one only has $\textsf{csk}$ without $\mathbf{c_x}$.
			\end{itemize}
		\item \cite{10.1007/978-3-642-01957-9_7, pradel2021privacypreservingbiometricmatchingusing}: The user owns the secret key for the HE. The server homomorphically computes the encryption of $\textsf{HW}(\mathbf{b} \oplus \mathbf{b}^\prime) + R$, where $R$ is a random value, and sends it to the user. The user decrypts the value $\textsf{HW}(\mathbf{b} \oplus \mathbf{b}^\prime) + R$, sends it back to the server. The server recovers $\textsf{HW}(\mathbf{b} \oplus \mathbf{b}^\prime)$ by subtracting from $R$.

	\end{itemize}

	\item Fuzzy extractor \cite{10.1145/1030083.1030096, 7980010}: This requires either the enrollment phase passes a public string $Q$ to the authentication phases, or the server sends $Q$ to the user on authentication.

	\item Oblivious transfer \cite{cryptoeprint:2012/586}: The server knows $\mathbf{b}$. Run $k$ OT protocols, where $k$ is the length of $\mathbf{b}$ and $\mathbf{b}^\prime$. Finally after the protocol, the user will have $R$. The server will have $T = \textsf{HW}(\mathbf{b} \oplus \mathbf{b}^\prime) + R$. The user sends $R$ to the server, and the server recovers $\textsf{HW}(\mathbf{b} \oplus \mathbf{b}^\prime)$.

\end{itemize}

%-------------------

\newpage

%-------------------

\iffalse

\section{Achievability of $\mathcal{O}^\prime_{\textsf{Enc}}$-RUF Security}

\begin{assumption}
\label{assump:random_key_ct}

Let $\textsf{FE}$ be an fh-IPFE scheme and $(\textsf{msk}, \textsf{pp}) \gets \textsf{FE.Setup}(1^\lambda)$. Assume that given $\textsf{pp}$, there exist PPT algorithms $\textsf{RandKeyGen}$ and $\textsf{RandEnc}$ that can generate $\textsf{FE.KeyGen}(\textsf{msk}, \mathbf{r})$ and $\textsf{FE.Enc}(\textsf{msk}, \mathbf{r})$ for some random vector $\mathbf{r} \in \mathbb{F}^k$, respectively.

\end{assumption}

Note that constructions in \cite{10.1007/978-3-319-45871-7_24, cryptoeprint:2016/440} satisfy Assumption \ref{assump:random_key_ct}.

\begin{theorem}
\label{thm:fh-IPFE:ind-OEnc-ruf}
Given Assumption \ref{assump:random_key_ct}. If \textsf{FE} is fh-IND and $\emptyset$-RUF, then $\textsf{FE}$ is also $\mathcal{O}^\prime_{\textsf{Enc}}$-RUF.

\end{theorem}

\begin{proof}

Given an adversary $\mathcal{A}$ in the $\textsf{RUF}^{\mathcal{O}^\prime_{\textsf{Enc}}}_{\textsf{FE}}$ game, consider the reduction adversary $\mathcal{R}$ in Algorithm \ref{alg:red:ind-OEnc-ruf} which plays the \textsf{fh-IND} game. $\mathcal{R}$ simulates $\mathcal{O}_\textsf{Enc}^\prime(\mathbf{y}^\prime)$ by first sampling a $\mathbf{r}^\prime \gets \mathbb{F}^k$ and returning $\mathcal{O}_\textsf{Enc}(\mathbf{y}^\prime, \mathbf{r}^\prime)$.

\begin{figure}[h]
\centering

	\begin{minipage}{0.4\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\mathcal{R}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}}(\textsf{pp})$}
	\label{alg:red:ind-OEnc-ruf}
	\begin{algorithmic}[1]
		\State $\mathbf{c} \gets \textsf{RandKeyGen}(\textsf{pp})$. 

		\State ${\mathbf{\tilde{z}}} \gets {\mathcal{A}}^{\mathcal{O}^\prime_{\textsf{Enc}}} (\textsf{pp}, \mathbf{c})$

		\State $s \gets \textsf{FE.Dec}( \textsf{pp}, \mathbf{c}, \mathbf{\tilde{z}} )$
		
		\If{$ s \neq \bot$}
			\State \Return $\tilde{b} = 0$
		\Else
			\State \Return $\tilde{b} = 1$
		\EndIf

	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	\hspace{0.05\textwidth}
	\begin{minipage}{0.4\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\mathcal{A}^\prime (\textsf{pp})$}
	\label{alg:adv:ind-OEnc-ruf}
	\begin{algorithmic}[1]
		\State $\mathbf{c} \gets \textsf{RandKeyGen}(\textsf{pp})$. 

		\State ${\mathbf{\tilde{z}}} \gets {\mathcal{A}}^{\mathcal{O}^\prime_{\textsf{Enc}}} (\textsf{pp}, \mathbf{c})$

		\State \Return $\mathbf{\tilde{z}}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\end{figure}

By Assumption \ref{assump:random_key_ct}, $\mathbf{c}$ looks like an honest key of some random vector $\mathbf{r}$. If the challenge bit $b = 0$, $\mathcal{R}$ perfectly simulates an $\textsf{RUF}^{\mathcal{O}^\prime_{\textsf{Enc}}}_{\textsf{FE}}$ game for $\mathcal{A}$ and $\Pr[\tilde{b} = 0 \mid b = 0] = \Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{Enc}}}_{\textsf{FE}}(\mathcal{A}) \to 1 ]$. On the other hand, if the challenge bit $b = 1$, then $\mathcal{R}$ simulates an $\textsf{RUF}^{\emptyset}_{\textsf{FE}}$ adversary $\mathcal{A}^\prime$ in Algorithm \ref{alg:adv:ind-OEnc-ruf}. $\mathcal{A}^\prime$ runs $\mathcal{A}$ and simulates $\mathcal{O}^\prime_{\textsf{Enc}}(\mathbf{y}^\prime)$ by simply returning $\textsf{RandEnc}(\textsf{pp})$. Therefore, $\Pr[\tilde{b} = 0 \mid b = 1] = \Pr[ \textsf{RUF}^{\emptyset}_{\textsf{FE}}(\mathcal{A}^\prime) \to 1 ]$.

In conclusion,
\begin{align*}
	\Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] 
	&= \Pr[b = 0] \cdot \Pr[\tilde{b} = 0 \mid b = 0] + \Pr[b = 1] \cdot \Pr[\tilde{b} = 1 \mid b = 1] \\
	&= \frac{1}{2} \left( \Pr[\textsf{RUF}^{\mathcal{O}^\prime_{\textsf{Enc}}}_{\textsf{FE}}(\mathcal{A}) \to 1] + 1 - \Pr[ \textsf{RUF}^{\emptyset}_{\textsf{FE}}(\mathcal{A}^\prime) \to 1 ] \right) \\
	&= \frac{1}{2} + \frac{1}{2} \left( \Pr[\textsf{RUF}^{\mathcal{O}^\prime_{\textsf{Enc}}}_{\textsf{FE}}(\mathcal{A}) \to 1] - \Pr[ \textsf{RUF}^{\emptyset}_{\textsf{FE}}(\mathcal{A}^\prime) \to 1 ] \right)
\end{align*}

Since $\Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} = \left| \Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] - \frac{1}{2} \right|$ and $\Adv_{\textsf{FE}, \mathcal{A}^\prime }^{\textsf{RUF}, \emptyset} = \Pr[\textsf{RUF}^{\emptyset}_{\textsf{FE}}(\mathcal{A}^\prime) \to 1 ]$ is negligible,
\[
	\Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{Enc}}}(\mathcal{A}) \to 1]  = 2 \cdot \Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} + \Adv_{\textsf{FE}, \mathcal{A}^\prime }^{\textsf{RUF}, \emptyset} = \negl.
\]

\end{proof}

With a similar proof, one can also show that

\begin{theorem}
\label{thm:fh-IPFE:ind-OEnc-gamma-ruf}
Given Assumption \ref{assump:random_key_ct}. If \textsf{FE} is fh-IND and $\{ \emptyset, \gamma \}$-RUF, then $\textsf{FE}$ is also $\{ \mathcal{O}^\prime_{\textsf{Enc}}, \gamma \}$-RUF.

\end{theorem}

Since $\{ \mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma \}$-RUF implies $\{ \emptyset, \gamma \}$-RUF, with Theorem \ref{thm:fh-IPFE:ind-OKeyGen-gamma-ruf}, we have the following corollary.

\begin{corollary}
\label{cor:fh-IPFE:ind-OKeyGen-OEnc-ruf}
Given Assumption \ref{assump:only-return-valid-ct} and \ref{assump:random_key_ct}. If \textsf{FE} is fh-IND, then $\textsf{FE}$ is both $\{ \mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma \}$-RUF and $\{ \mathcal{O}^\prime_{\textsf{Enc}}, \gamma \}$-RUF for any $\gamma \leq (1 - \frac{1}{\poly}) \cdot \|\mathbb{F}\|$.
\end{corollary}


\section{One-Way Game}

\begin{figure}[h]
\centering

	\begin{minipage}[t]{0.55\textwidth}
	\begin{algorithm}[H]
	\caption{$\textsf{OW}_{\Pi, \mathbb{B}}(\mathcal{A})$}
	\label{alg:ow_game}
	\begin{algorithmic}[1]

		\State $\mathcal{B} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$

		\State $\textsf{esk}, \textsf{psk}, \textsf{csk} \gets \textsf{Setup}(1^\lambda)$

		\State $\mathbf{b} \gets \textsf{getEnroll}^{\mathcal{O}_{\mathcal{B}}}()$

		\State $\mathbf{c_x} \gets \textsf{Enroll}(\textsf{esk}, \mathbf{b})$

		\State $\mathbf{\tilde{b}} \gets \mathcal{A}( \textsf{option} )$

		\State $s \gets \textsf{BioCompare}( \mathbf{\tilde{b}}, \mathbf{b})$
		\State \Return $ \textsf{Verify}(s) $
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\label{fig:ow_game}
\end{figure}

\noindent $\textsf{option}$ can be $\mathbf{c_x}, \textsf{esk}, \textsf{psk}, \textsf{csk}$ or oracles $\mathcal{O}_{\textsf{Enroll}}, \mathcal{O}_{\textsf{Probe}}, \mathcal{O}^\prime_{\textsf{Enroll}}, \mathcal{O}^\prime_{\textsf{Probe}}$.

In the reusable fuzzy extractor paper \cite{10.1145/1030083.1030096}, if public strings related to personal information are generated many times, the sensitive information might leak. In our setting, it is a little similar to having multiple $\mathbf{c_x}^{(i)} \gets \textsf{Enroll}(\textsf{esk}_i, \mathbf{b})$.

To model reusability, I think we can consider either providing $\mathbf{c_x}^{(i)} \gets \textsf{Enroll}(\textsf{esk}_i, \mathbf{b})$ for different $\textsf{esk}_i$, or just providng $\mathcal{O}^\prime_{\textsf{Enroll}}$.

\fi

%-------------------

\newpage

%-------------------

%-------------------
%% Backup File

% \input{backup.tex}

%-------------------
%% Reference List
\pagebreak

\nocite{*}
\printbibliography


\end{document}
