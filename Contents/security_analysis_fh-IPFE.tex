%%%%%%%%%%%%%%%%%%%%

% Project Name: Semester Project Fall 2024 for EPFL
% File: security_analysis_fh-IPFE.tex
% Author: Keng-Yu Chen

%%%%%%%%%%%%%%%%%%%%

\begin{definition}[Function-Hiding Inner Product Functional Encryption (adapted from \cite{cryptoeprint:2016/440}) ]
\label{def:fh-IPFE}
	A \emph{function-hiding inner product functional encryption} (fh-IPFE) scheme $\sf FE$ for a field $\mathbb{F}$ and input length $k$ is composed of PPT algorithms $\textsf{FE.Setup}$, $\textsf{FE.KeyGen}$, $\textsf{FE.Enc}$, and $\textsf{FE.Dec}$:

	\begin{itemize}
	
		\item $\textsf{FE.Setup}(1^\lambda) \to \textsf{msk}, \textsf{pp}$: It outputs the public parameter $\textsf{pp}$ and the master secret key $\textsf{msk}$.
	
		\item $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x}) \to \textsf{sk}_{\mathbf{x}}$: It generates the functional decryption key $\textsf{sk}{\mathbf{x}}$ for an input vector $\mathbf{x} \in \mathbb{F}^k$. 
	
		\item $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y}) \to \textsf{ct}_{\mathbf{y}}$: It encrypts the input vector $\mathbf{y} \in \mathbb{F}^k$ to the ciphertext $\textsf{ct}_{\mathbf{y}}$. 
	
		\item $\textsf{FE.Dec}(\textsf{pp}, \textsf{sk}_{\mathbf{x}}, \textsf{ct}_{\mathbf{y}}) \to z$: It outputs a value $z \in \mathbb{F}$ or an error symbol $\bot$.
	
	\end{itemize}
	
	\paragraph{\textbf{Correctness}} An fh-IPFE scheme \textsf{FE} is \emph{correct} if for all non-zero $ \mathbf{x}, \mathbf{y} \in \mathbb{F}^k \setminus \{\mathbf{0}\}$, let $(\textsf{msk}, \textsf{pp}) \gets \textsf{FE.Setup}(1^\lambda)$, we have
	\[
		\textsf{FE.Dec}( \textsf{pp}, \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x}), \textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y}) ) = \langle \mathbf{x}, \mathbf{y} \rangle \in \mathbb{F}.
	\]

\end{definition}

%-------------------

\subsection{Instantiation with an fh-IPFE Scheme}
\label{sec:fh-IPFE-instantiation}

Let $\textsf{FE} = (\textsf{FE.Setup}, \textsf{FE.KeyGen}, \textsf{FE.Enc}, \textsf{FE.Dec})$ be an fh-IPFE scheme. Following \cite{cryptoeprint:2023/481}, we can instantiate a biometric authentication scheme using $\textsf{FE}$ with the distance metric the Euclidean distance.
Let $\textsf{getEnroll}^{\mathcal{O}_{\mathcal{B}}}()$ and $\textsf{getProbe}^{\mathcal{O}_{\mathcal{B}}}()$ both output vectors in $ \{0, 1, \cdots, m \}^k$ for all biometric distributions $\mathcal{B} \in \mathbb{B}$. 
For a pre-defined real number $\tau \geq 0$, define
\[
	\textsf{BioCompare}(\mathbf{b}, \mathbf{b}^\prime) \to \| \mathbf{b} - \mathbf{b}^\prime\|^2 \quad \text{and} \quad 
	\textsf{Verify}(s) \to 
	\begin{cases} 
		1 & \text{if } \sqrt{s} \leq \tau \\
		0 & \text{if } \sqrt{s} > \tau
	\end{cases}.
\]

Now, let the associated field of $\textsf{FE}$ be $\mathbb{Z}_q$, where $q$ is a prime number larger than the maximum possible Euclidean distance $m^2 \cdot k$. The scheme is instantiated as follows.

\begin{itemize}

	\item $\textsf{Setup}(1^\lambda)$: It calls $\textsf{FE.Setup}(1^\lambda) \to \textsf{msk}, \textsf{pp}$ and outputs $\textsf{esk} \gets (\textsf{msk}, \textsf{pp})$, $\textsf{psk} \gets (\textsf{msk}, \textsf{pp})$ and $\textsf{csk} \gets \textsf{pp}$.

	\item $\textsf{Enroll}(\textsf{esk}, \mathbf{b})$: On input a template vector $\mathbf{b} = (b_1, b_2, \cdots, b_k)$, the algorithm first encodes it as $\mathbf{x} = (x_1, x_2, \cdots, x_{k+2}) = (b_1, b_2, \cdots, b_k, 1, \|\mathbf{b}\|^2)$. Next, it calls $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x}) \to \textsf{sk}_{\mathbf{x}}$ and outputs $\mathbf{c_x} \gets \textsf{sk}_{\mathbf{x}}$.

	\item $\textsf{Probe}(\textsf{psk}, \mathbf{b}^\prime)$: On input a template vector $\mathbf{b}^\prime = (b_1^\prime, b_2^\prime, \cdots, b_k^\prime)$, the algorithm first encodes it as $\mathbf{y} = (y_1, y_2, \cdots, y_{k+2}) = (-2b_1^\prime, -2b_2^\prime, \cdots, -2b_k^\prime, \|\mathbf{b}^\prime\|^2, 1)$. Next, it calls $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y}) \to \textsf{ct}_{\mathbf{y}}$ and outputs $\mathbf{c_y} \gets \textsf{ct}_{\mathbf{y}}$.

	\item $\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{c_y)}$: It calls $\textsf{FE.Dec}(\textsf{pp}, \mathbf{c_x}, \mathbf{c_y}) \to s$ and outputs the value $s$.

\end{itemize}

By the correctness of the functional encryption scheme $\sf FE$, we have
\[
	s = \textsf{FE.Dec}(\textsf{pp}, \mathbf{c_x}, \mathbf{c_y}) = \langle \mathbf{x}, \mathbf{y} \rangle = \sum_{i=1}^k -2b_ib_i^\prime + \|\mathbf{b}\|^2 + \|\mathbf{b}^\prime\|^2 = \| \mathbf{b} - \mathbf{b}^\prime \|^2.
\]
which is equal to $\textsf{BioCompare}(\mathbf{b}, \mathbf{b}^\prime)$. Therefore, if two templates $\mathbf{b}$ and $\mathbf{b}^\prime$ are close enough such that $\|\mathbf{b} - \mathbf{b}^\prime\| \leq \tau$, the scheme results in $r = 1$, a successful authentication.

Instantiated with an fh-IPFE scheme in this way, the comparison secret key $\textsf{csk}$ is public, and the enrollment secret key $\textsf{esk}$ and probe secret key $\textsf{psk}$ are the same. Anyone with access to the enrollment message $\mathbf{c_x}$ and either $\textsf{esk}$ or $\textsf{psk}$ can probe any (invalidly encoded) $\mathbf{y}^{\prime} \in \Z_q^{k+2}$ and find $\langle \mathbf{x}, {\mathbf{y}^\prime} \rangle$ to get partial or full information about the biometric template $\mathbf{b}$. Even if the adversary has no $\textsf{esk}$ or $\textsf{psk}$, if it can sample ciphertexts $\mathbf{c_{y}}$ corresponding to some unknown random vectors $\mathbf{y}$, and if the field size $q$ is not large enough, it can also find a forged $\mathbf{c_{y^*}}$ such that $\langle \mathbf{x}, \mathbf{y^*} \rangle \leq \tau$ with a good probability to impersonate the user by sampling many times offline.

We note that the construction in \cite{cryptoeprint:2023/481} is applying Theorem \ref{thm:sEUF-CMA-esk-csk} on this instantiation. The user holds \textsf{esk} and \textsf{psk} while the server holds \textsf{csk}, the public parameter of the functional encryption scheme.
%-------------------

Let $\Pi$ be an authentication scheme instantiated by an fh-IPFE scheme \textsf{FE} for a field $\mathbb{F} = \Z_q$. In the following, we discuss the UF and IND security of $\Pi$ in this section. For this, we first define two security notions of \textsf{FE}\footnote{In security definition, the vectors lie in $\Z_q^k$, but we consider $\Z_q^{k+2}$ when discussing the instantiation $\Pi$.}.

%-------------------

\subsection{fh-IND Security of \textsf{FE}}

Given an fh-IPFE scheme \textsf{FE}, we define the \textsf{fh-IND} game \cite{cryptoeprint:2016/440} in Algorithm \ref{alg:ind-fh-IPFE}.

\begin{figure}[h]
\centering

	\begin{minipage}[t]{0.4\textwidth}
	\begin{algorithm}[H]
	\caption{$\textsf{fh-IND}_{\textsf{FE}}(\mathcal{A})$}
	\label{alg:ind-fh-IPFE}
	\begin{algorithmic}[1]
		\State $b \getsdollar \{0, 1\}$

		\State $\textsf{msk}, \textsf{pp} \gets \textsf{FE.Setup}(1^\lambda)$

		\State $\tilde{b} \gets \mathcal{A}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}} ( \textsf{pp} )$

		\State \Return $1_{\tilde{b} = b}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\label{fig:ind-fh-IPFE}
\end{figure}

\begin{itemize}

	\item $\mathcal{O}_{\textsf{KeyGen}}(\cdot, \cdot)$: On input pair $(\mathbf{x}^{(0)}, \mathbf{x}^{(1)})$, where $\mathbf{x}^{(0)}, \mathbf{x}^{(1)} \in \Z_q^k \setminus \{\mathbf{0}\}$, it outputs $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x}^{(b)} )$.

	\item $\mathcal{O}_{\textsf{Enc}}(\cdot, \cdot)$: On input pair $(\mathbf{y}^{(0)}, \mathbf{y}^{(1)})$, where $\mathbf{y}^{(0)}, \mathbf{y}^{(1)} \in \Z_q^k \setminus \{\mathbf{0}\}$, it outputs $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y}^{(b)} )$.

\end{itemize}

\noindent To avoid trivial attacks, we consider \emph{admissible adversaries}.

\begin{definition}[Admissible Adversary]

	Let $\mathcal{A}$ be an adversary in an \textsf{fh-IND} game, and let $ (\mathbf{x}_1^{(0)}, \mathbf{x}_1^{(1)}), \cdots, (\mathbf{x}_{Q_K}^{(0)}, \mathbf{x}_{Q_K}^{(1)})$ be its queries to $\mathcal{O}_{\textsf{KeyGen}}$ and $(\mathbf{y}_1^{(0)}, \mathbf{y}_1^{(1)}), \cdots, (\mathbf{y}_{Q_E}^{(0)}, \mathbf{y}_{Q_E}^{(1)})$ be its queries to $\mathcal{O}_{\textsf{Enc}}$.
	We say $\mathcal{A}$ is \emph{admissible} if $\forall i \in [Q_K], \forall j \in [Q_E]$, we have
\[
	\left\langle {\mathbf{x}^{(0)}_{i}}, {\mathbf{y}^{(0)}_{j}} \right\rangle = \left\langle {\mathbf{x}^{(1)}_{i}}, {\mathbf{y}^{(1)}_{j}} \right\rangle
\]

\end{definition}


\begin{definition}[fh-IND Security]

	An fh-IPFE scheme \textsf{FE} is called fh-IND secure if for any admissible adversary $\mathcal{A}$, the advantage of $\mathcal{A}$ in the $\textsf{fh-IND}$ game in Algorithm \ref{alg:ind-fh-IPFE} is

\[
	\Adv_{\textsf{FE}, \mathcal{A}}^{\textsf{fh-IND}} := \left| \Pr[\textsf{fh-IND}_{\textsf{FE}}(\mathcal{A}) \to 1 ] - \frac{1}{2} \right| = \negl.
\]

\end{definition}

We note that fh-IND security is a standard notion for an fh-IPFE, and constructions in \cite{cryptoeprint:2015/1255, 10.1007/978-3-319-45871-7_24, cryptoeprint:2016/440} are proven fh-IND secure. However, fh-IND security may not be sufficient for the UF security of the instantiation in Section \ref{sec:fh-IPFE-instantiation}. 

\begin{theorem}
\label{thm:fh-IPFE-not-uf}
An instantiation $\Pi$ using the construction in \cite{cryptoeprint:2016/440} is not \textsf{option}-UF secure for any \textsf{option}.

\end{theorem}

\noindent We recall the construction in \cite{cryptoeprint:2016/440} in Appendix \ref{sec:fh-IPFE-construction}.

\begin{proof}

Let $\mathcal{A}$ be a \textsf{UF} game adversary that returns $(K_1, K_2) = (1, (1, \cdots, 1))$. Then, in the decryption,
\[
	D_1 = e(g_1, g_2)^{0} = 1 \quad \text{and} \quad D_2 = e(g_1, g_2)^0 = 1
\]
As $D_1^0 = D_2$, the decryption returns $0$ and let the adversary win the game with probability $1$.

\end{proof}

%-------------------

\subsection{RUF Security of \textsf{FE}}
\label{sec:security_analysis:fh-IPFE:ruf}

We also define the $\textsf{RUF}^{\mathcal{O}}_\textsf{FE}$ game in Algorithm \ref{alg:ruf-fh-IPFE}.

\begin{figure}[H]
\centering

	\begin{minipage}[t]{0.55\textwidth}
	\begin{algorithm}[H]
	\caption{$\textsf{RUF}^{\mathcal{O}}_{\textsf{FE}}(\mathcal{A})$}
	\label{alg:ruf-fh-IPFE}
	\begin{algorithmic}[1]
		\State $\mathbf{r} \getsdollar \mathbb{F}^{k}$ \label{alg:oracle-ruf-fh-IPFE:r}

		\State $\textsf{msk}, \textsf{pp} \gets \textsf{FE.Setup}(1^\lambda)$

		\State $\textsf{sk}_{\mathbf{r}} \gets \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{r})$

		\State $\mathbf{\tilde{z}} \gets \mathcal{A}^{\mathcal{O}} ( \textsf{pp}, \textsf{sk}_{\mathbf{r}} )$

		\If{$\mathbf{\tilde{z}}$ is equal to any output of $\mathcal{O}^\prime_{\textsf{Enc}}$ }
			
			\State \Return $0$
		
		\EndIf

		\State $s \gets \textsf{FE.Dec}(\textsf{pp}, \textsf{sk}_{\mathbf{r}}, \mathbf{\tilde{z}} )$

		\State \Return $1_{s \neq \bot}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\end{figure}

The oracle $\mathcal{O}$ can be nothing or include the following options based on the threat model.

\begin{itemize}

	\item $\mathcal{O}^\prime_{\textsf{KeyGen}}(\cdot)$: On input $\mathbf{x}^\prime$, it outputs $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x}^\prime)$.
	
	\item $\mathcal{O}^\prime_{\textsf{Enc}}(\cdot)$: On input $\mathbf{y}^\prime$, it outputs $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y}^\prime)$. The adversary is required to return $\mathbf{\tilde{z}}$ that is not equal to any output of this oracle.
\end{itemize}

\begin{definition}[RUF Security]

	An fh-IPFE scheme \textsf{FE} is called $\mathcal{O}$-RUF secure if for any adversary $\mathcal{A}$, the advantage of $\mathcal{A}$ in the $\textsf{RUF}^{\mathcal{O}}_\textsf{FE}$ game in Algorithm \ref{alg:ruf-fh-IPFE} is

\[
	\Adv_{\textsf{FE}, \mathcal{A}}^{\textsf{RUF}, \mathcal{O}} := \Pr[\textsf{RUF}^{\mathcal{O}}_{\textsf{FE}}(\mathcal{A}) \to 1 ] = \negl.
\]

\noindent We say $\textsf{FE}$ is RUF secure if it is $\{ \mathcal{O}^\prime_{\textsf{KeyGen}}, \mathcal{O}^\prime_{\textsf{Enc}} \}$-RUF secure.

\end{definition}

\subsubsection{Achievability of RUF Security}

We note that RUF security is a new security notion of fh-IPFE but can be achieved with a digital signature scheme. Let $\textsf{Sig} = ( \textsf{Sig.KeyGen}, \textsf{Sig.Sign}, \textsf{Sig.Verify} )$ be an sEUF-CMA signature scheme. By adding $\textsf{Sig}$, an fh-IPFE scheme $\textsf{FE}$ can be upgraded to an RUF scheme $\textsf{FE}^\prime$. 

\begin{itemize}

	\item $\textsf{FE}^\prime \textsf{.Setup}(1^\lambda)$: Run $\textsf{FE.Setup}(1^\lambda) \to (\textsf{msk}, \textsf{pp})$ and $\textsf{Sig.KeyGen}(1^\lambda) \to (\textsf{sk}_{\textsf{Sig}}, \textsf{pk}_{\textsf{Sig}} )$. Output $\textsf{msk}^\prime = (\textsf{msk}, \textsf{sk}_\textsf{Sig})$ and $\textsf{pp}^\prime = (\textsf{pp}, \textsf{pk}_{\textsf{Sig}})$.

	\item $\textsf{FE}^\prime \textsf{.KeyGen}(\textsf{msk}^\prime, \mathbf{x})$: Run $\textsf{FE.KeyGen}(\textsf{msk}, \mathbf{x}) \to \textsf{sk}_{\mathbf{x}}$ and output $\textsf{sk}_{\mathbf{x}}^\prime \gets \textsf{sk}_{\mathbf{x}}$.

	\item $\textsf{FE}^\prime \textsf{.Enc}(\textsf{msk}^\prime, \mathbf{y})$: Run $\textsf{FE.Enc}(\textsf{msk}, \mathbf{y}) \to \textsf{ct}_{\mathbf{y}}$ and sign $\textsf{ct}_{\mathbf{y}}$ by $\textsf{Sig.Sign}(\textsf{sk}_{\textsf{Sig}}, \textsf{ct}_{\mathbf{y}}) \to \sigma$. Output $\textsf{ct}_{\mathbf{y}}^\prime = (\textsf{ct}_{\mathbf{y}}, \sigma)$.

	\item $\textsf{FE}^\prime \textsf{.Dec}(\textsf{pp}^\prime, \textsf{sk}_{\mathbf{x}}^\prime, \textsf{ct}_{\mathbf{y}}^\prime )$: Output the decryption $\textsf{FE.Dec}(\textsf{pp}, \textsf{sk}_{\mathbf{x}}, \textsf{ct}_{\mathbf{y}})$ if the verification $\textsf{Sig.Verify}(\textsf{pk}_{\textsf{Sig}}, \textsf{ct}_{\mathbf{y}}, \sigma ) = 1$. Otherwise, output $\bot$.

\end{itemize}

\begin{theorem}

For any fh-IPFE $\textsf{FE}$, $\textsf{FE}^\prime$ is an RUF secure fh-IPFE.

\end{theorem}

\begin{proof}

Given an adversary $\mathcal{A}$ in the $\textsf{RUF}^{\mathcal{O}_{\textsf{KeyGen}}^\prime, \mathcal{O}_{\textsf{Enc}}^\prime}_{\textsf{FE}^\prime}$ game, consider the reduction adversary $\mathcal{R}$ in Algorithm \ref{alg:red:sEUF-CMA:RUF} which plays the \textsf{sEUF-CMA} game of $\textsf{Sig}$. $\mathcal{R}$ is given a verification public key $\textsf{pk}_{\textsf{Sig}}$ and a signing oracle $\mathcal{O}_{\textsf{Sig}}$ and returns a forged message-signature pair that is not equal to any previous answer of $\mathcal{O}_{\textsf{Sig}}$. To run $\mathcal{A}$, $\mathcal{R}$ simulates each oracle in the following way.

\begin{itemize}
	\item $\mathcal{O}_{\textsf{KeyGen}}^\prime(\mathbf{x}^\prime)$: Return $\textsf{FE.KeyGen}(\textsf{msk}, \mathbf{x})$.

	\item $\mathcal{O}_{\textsf{Enc}}^\prime(\mathbf{y}^\prime)$: Run $\textsf{FE.Enc}(\textsf{msk}, \mathbf{y}) \to \textsf{ct}_{\mathbf{y}}$ and call the signing oracle $\mathcal{O}_{\textsf{Sign}}(\textsf{ct}_{\mathbf{y}}) \to \sigma$. Output $\textsf{ct}_{\mathbf{y}}^\prime = (\textsf{ct}_{\mathbf{y}}, \sigma)$.
\end{itemize}

\begin{figure}[h]
\centering
	
	\begin{minipage}[t]{0.5\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\mathcal{R}^{\mathcal{O}_{\textsf{Sign}}}( \textsf{pk}_{\textsf{Sig}} )$}
	\label{alg:red:sEUF-CMA:RUF}
	\begin{algorithmic}[1]

		\State $\mathbf{r} \gets \mathbb{F}^k$

		\State $\textsf{msk}, \textsf{pp} \gets \textsf{FE.Setup}(1^\lambda)$

		\State $\textsf{sk}_{\mathbf{r}} \gets \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{r})$

		\State $\textsf{pp}^\prime \gets (\textsf{pp}, \textsf{pk}_{\textsf{Sig}})$

		\State $\mathbf{\tilde{z}} \gets {\mathcal{A}}^{\mathcal{O}_{\textsf{KeyGen}}^\prime, \mathcal{O}_{\textsf{Enc}}^\prime } (\textsf{pp}^\prime, \textsf{sk}_{\mathbf{r}})$ \label{alg:red:sEUF-CMA:RUF:A}

		\State Parse $(\textsf{ct}_{\mathbf{z}}, \sigma^\prime) \gets \mathbf{\tilde{z}}$

		\State \Return $(\textsf{ct}_{\mathbf{z}}, \sigma^\prime)$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\end{figure}

$\mathcal{R}$ perfectly simulates a $\textsf{RUF}$ game for $\mathcal{A}$, and if $\mathcal{A}$ wins the $\textsf{RUF}$ game, $(\textsf{ct}_{\mathbf{z}}, \sigma^\prime)$ is not equal to any previous answer of $\mathcal{O}_{\textsf{Enc}}^\prime$, and therefoere not equal to any previous message-signature pair $(\textsf{ct}_{\mathbf{y}}, \sigma)$ given by the signing oracle $\mathcal{O}_{\textsf{Sign}}$. Now, since $\textsf{Sig}$ is sEUF-CMA secure,
\[
	\Pr[\textsf{RUF}^{ \mathcal{O}^\prime_{\textsf{KeyGen}}}(\mathcal{A}) \to 1] \leq \Pr[ \textsf{Sig.Verify}(\textsf{pk}_{\textsf{Sig}}, \textsf{ct}_{\mathbf{z}}, \sigma^\prime) = 1 ] = \negl.
\]


\end{proof}

%-------------------


\subsection{UF Security of $\Pi$}
\label{sec:security_analysis:fh-IPFE:uf}

We first consider \textsf{option}-UF security when $\textsf{option}$ includes $\mathcal{O}_\textsf{Enroll}$. Note that in this instantiation, $\textsf{csk}$ is the public parameter $\textsf{pp}$ of \textsf{FE} and assumed to be given to all adversaries. 

\begin{theorem}
\label{thm:fh-IPFE:ind-ruf-OB-Enroll}
	Let $\textsf{option} = \{ \textsf{csk}, \mathbf{c_x}, \mathcal{O}_\mathcal{B}, \mathcal{O}_{\textsf{Enroll}} \}$. For any distribution family $\mathbb{B}$, if \textsf{FE} is fh-IND secure and $\mathcal{O}^\prime_{\textsf{KeyGen}}$-RUF secure, then $\Pi$ is $\textsf{option}$-UF secure. 
\end{theorem}


\begin{proof}

Given an adversary $\mathcal{A}$ in the $\textsf{UF}_{\textsf{option}}$ game, consider the reduction adversary $\mathcal{R}$ in Algorithm \ref{alg:red:ind-uf-OB-Enroll} which plays the \textsf{fh-IND} game. $\mathcal{R}$ runs $\mathcal{A}$ and simulates $\mathcal{O}_{\textsf{Enroll}}( \textsf{esk}, \mathbf{b}^\prime )$ by first encoding $\mathbf{b}^\prime = (b_1^\prime, \cdots, b_k^\prime)$ into $\mathbf{x}^\prime = (b_1^\prime, \cdots, b_k^\prime, 1, \|\mathbf{b}^\prime\|^2)$ and calling $\mathcal{O}_{\textsf{KeyGen}}(\mathbf{x}^\prime, \mathbf{x}^\prime)$ given in the \textsf{fh-IND} game.  Note that since $\mathcal{R}$ never calls $\mathcal{O}_{\textsf{Enc}}$, it is an admissible adversary.

\begin{figure}[h]
\centering
	
	\begin{minipage}[t]{0.5\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\mathcal{R}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}}(\textsf{pp})$}
	\label{alg:red:ind-uf-OB-Enroll}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$ \label{alg:red:ind-uf-OB-Enroll:B}

		\State $\mathbf{b} = (b_1, \cdots, b_k) \gets \textsf{getEnroll}^{\mathcal{O}_{\mathcal{B}}}()$

		\State $\mathbf{x} \gets (b_1, \cdots, b_k, 1, \|\mathbf{b}\|^2)$

		\State $\mathbf{r} \getsdollar \mathbb{F}^{k+2}$
		
		\State $\textsf{sk} \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{x}, \mathbf{r})$ \label{alg:red:ind-uf-OB-Enroll:sk}

		\State ${\mathbf{\tilde{z}}} \gets {\mathcal{A}}^{\mathcal{O}_\mathcal{B}, \mathcal{O}_\textsf{Enroll} } ( \textsf{pp}, \textsf{sk} )$ \label{alg:red:ind-uf-OB-Enroll:A}

		\State $s \gets \textsf{FE.Dec}( \textsf{pp}, \textsf{sk}, \mathbf{\tilde{z}} )$

		\If{$\textsf{Verify}(s) = 1$} \label{alg:red:ind-uf-OB-Enroll:verify}
			\State \Return $\tilde{b} = 0$
		\Else
			\State \Return $\tilde{b} \getsdollar \{0, 1\}$
		\EndIf

	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\end{figure}

	If the challenge bit $b = 0$, then $\mathcal{R}$ perfectly simulates a $\textsf{UF}_{\textsf{option}}$ game for $\mathcal{A}$. Therefore, the probability that $\textsf{Verify}(s) = 1$ in Line \ref{alg:red:ind-uf-OB-Enroll:verify} is $\Pr[\textsf{UF}_{\textsf{option}}(\mathcal{A}) \to 1]$.

	For the case when the challenge bit $b = 1$, consider an adversary $\mathcal{A}^\prime$ in Algorithm \ref{alg:adv:ind-uf-OB-Enroll} in the $\textsf{RUF}^{ \mathcal{O}^\prime_{\textsf{KeyGen}} }$ game. $\mathcal{A}^\prime$ runs Line \ref{alg:red:ind-uf-OB-Enroll:B} and \ref{alg:red:ind-uf-OB-Enroll:A} of $\mathcal{R}$ and simulates $\mathcal{O}_{\textsf{Enroll}}( \textsf{esk}, \mathbf{b}^\prime )$ by first encoding $\mathbf{b}^\prime$ into $\mathbf{x}^\prime$ as before and calling $\mathcal{O}_\textsf{KeyGen}^\prime(\mathbf{x}^\prime)$ given in the $\textsf{RUF}^{ \mathcal{O}^\prime_{\textsf{KeyGen}} }$ game. 


\begin{figure}[h]
\centering

	\begin{minipage}[t]{0.45\textwidth}
	\begin{algorithm}[H]
	\caption{${\mathcal{A}^\prime}^{\mathcal{O}^\prime_{\textsf{KeyGen}} }(\textsf{pp}, \textsf{sk}_\mathbf{r})$}
	\label{alg:adv:ind-uf-OB-Enroll}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$ 
		
		\State $\mathbf{\tilde{z}} \gets {\mathcal{A}}^{\mathcal{O}_{\mathcal{B}}, \mathcal{O}_\textsf{Enroll} } (\textsf{pp}, \textsf{sk}_{\mathbf{r}})$

		\State \Return $\mathbf{\tilde{z}}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\end{figure}

Now, if the challenge bit $b = 1$, then $\mathcal{R}$ perfectly simulates $\mathcal{A}^\prime$ in the $\textsf{RUF}^{ \mathcal{O}^\prime_{\textsf{KeyGen}} }$ game. The probability that $\textsf{Verify}(s) = 1$ in Line \ref{alg:red:ind-uf-OB-Enroll:verify} is smaller than $\Pr[s \neq \bot] = \Pr[\textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}}_{\textsf{FE}}(\mathcal{A}^\prime) \to 1 ]$

In conclusion,
\begin{align*}
	\Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] 
	&= \Pr[b = 0] \cdot \left( \Pr[\textsf{Verify}(s) = 1 \mid b = 0] + \frac{1}{2} \cdot \Pr[\textsf{Verify}(s) = 0 \mid b = 0] \right) \\
	&\quad + \Pr[b = 1] \cdot \frac{1}{2} \cdot \Pr[\textsf{Verify}(s) = 0 \mid b = 1] \\
	&= \frac{1}{2} + \frac{1}{4} \left( \Pr[\textsf{Verify}(s) = 1 \mid b = 0] - \Pr[\textsf{Verify}(s) = 1 \mid b = 1] \right) \\
	&\geq \frac{1}{2} + \frac{1}{4} \left( \Pr[\textsf{UF}_\textsf{option}(\mathcal{A}) \to 1] - \Pr[\textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}}_{\textsf{FE}}(\mathcal{A}^\prime) \to 1 ] \right)
\end{align*}

\noindent Since both $\Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} = \left| \Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] - \frac{1}{2} \right|$ and $\Adv_{\textsf{FE}, \mathcal{A}^\prime}^{\textsf{RUF},\mathcal{O}^\prime_{\textsf{KeyGen}}} = \Pr[\textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}}_{\textsf{FE}}(\mathcal{A}^\prime) \to 1 ]$ are negligilbe,
\[
	\Pr[\textsf{UF}_\textsf{option}(\mathcal{A}) \to 1] \leq 4 \cdot \Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} + \Adv_{\textsf{FE}, \mathcal{A}^\prime}^{\textsf{RUF},\mathcal{O}^\prime_{\textsf{KeyGen}}} = \negl.
\]

\end{proof}


For $\textsf{option}$ that includes $\mathcal{O}_{\textsf{Probe}}$, we first note that for any $d \in \Z_q$ and any non-zero vector $\mathbf{r} \in \Z_q^{k+2} \setminus \{\mathbf{0}\}$, there exists a vector $\mathbf{y} \in \Z_q^{k+2}$ such that $\langle \mathbf{r}, \mathbf{y} \rangle = d$.

\begin{theorem}
\label{thm:fh-IPFE:ind-ruf-OB-Probe}
	Let $\textsf{option} = \{\textsf{csk}, \mathbf{c_x}, \mathcal{O}_\mathcal{B}, \mathcal{O}_\textsf{Probe}\}$. For any distribution family $\mathbb{B}$, if \textsf{FE} is fh-IND secure and $\mathcal{O}^\prime_{\textsf{Enc}}$-RUF secure, then $\Pi$ is $\textsf{option}$-UF secure. 
\end{theorem}


\begin{proof}

[There exists a flaw in this proof. Line \ref{alg:adv:ind-uf-OB-Probe:Dec} in Algorithm \ref{alg:adv:ind-uf-OB-Probe} is not feasible for current fh-IPFE constructions. I am now trying to solve this problem. Details are in Appendix \ref{sec:fixing-proof-thm-OB-Probe}]

Given an adversary $\mathcal{A}$ in the $\textsf{UF}_\textsf{option}$ game, consider the reduction adversary $\mathcal{R}$ in Algorithm \ref{alg:red:ind-uf-OB-Probe} which plays the \textsf{fh-IND} game. $\mathcal{R}$ runs $\mathcal{A}$ and simulates $\mathcal{O}_{\textsf{Probe}}$ in the following way.

\begin{itemize}

	\item $\mathcal{O}_{\textsf{Probe}}( \textsf{psk}, \mathbf{b}^\prime )$: On input $\mathbf{b}^\prime = (b_1^\prime, \cdots, b_k^\prime)$, it first encodes it as $\mathbf{y}^\prime = (-2b_1^\prime, \cdots, \allowbreak -2b_k^\prime, \|\mathbf{b}^\prime\|^2, 1)$. Next, it computes $d \gets \langle \mathbf{x}, {\mathbf{y}^\prime} \rangle$ and finds a vector $\mathbf{y}^{\prime\prime}$ such that $\langle \mathbf{r}, {\mathbf{y}^{\prime\prime}} \rangle = d$. Finally, it calls $\mathcal{O}_{\textsf{Enc}}(\mathbf{y}^\prime, {\mathbf{y}^{\prime\prime}})$, which is given by the \textsf{fh-IND} game, and returns the result.

\end{itemize}

\noindent Note that $(\mathbf{x}, \mathbf{r})$ is the only query of $\mathcal{R}$ to $\mathcal{O}_{\textsf{KeyGen}}$, and for any query $( \mathbf{y}^\prime, {\mathbf{y}^{\prime\prime}} )$ to $\mathcal{O}_{\textsf{Enc}}$, it satisfies $\langle \mathbf{x}, {\mathbf{y}^\prime} \rangle = \langle \mathbf{r}, {\mathbf{y}^{\prime\prime}} \rangle$. Hence, $\mathcal{R}$ is an admissible adversary.

\begin{figure}[h]
\centering
	
	\begin{minipage}[t]{0.6\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\mathcal{R}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}}(\textsf{pp})$}
	\label{alg:red:ind-uf-OB-Probe}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$ \label{alg:red:ind-uf-OB-Probe:B}

		\State $\mathbf{b} = (b_1, \cdots, b_k) \gets \textsf{getEnroll}^{\mathcal{O}_{\mathcal{B}}}()$

		\State $\mathbf{x} \gets (b_1, \cdots, b_k, 1, \|\mathbf{b}\|^2)$

		\State $\mathbf{r} \getsdollar \mathbb{F}^{k+2}$

		\State $\textsf{sk} \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{x}, \mathbf{r})$

		\State ${\mathbf{\tilde{z}}} \gets \mathcal{A}^{\mathcal{O}_{\mathcal{B}}, \mathcal{O}_{\textsf{Probe}} } ( \textsf{pp}, \textsf{sk})$

		\If{$\mathbf{\tilde{z}}$ is equal to any output of $\mathcal{O}_\textsf{Probe}$}

			\State \Return $\bot$

		\EndIf

		\State $s \gets \textsf{FE.Dec}( \textsf{pp}, \textsf{sk}, \mathbf{\tilde{z}} )$

		\If{$\textsf{Verify}(s) = 1$} \label{alg:red:ind-uf-OB-Probe:verify}
			\State \Return $\tilde{b} = 0$
		\Else
			\State \Return $\tilde{b} \getsdollar \{0, 1\}$
		\EndIf

	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\end{figure}

If the challenge bit $b = 0$, then $\mathcal{R}$ perfectly simulates a $\textsf{UF}_\textsf{option}$ game for $\mathcal{A}$. Therefore, the probability that $\textsf{Verify}(s) = 1$ in Line \ref{alg:red:ind-uf-OB-Probe:verify} is $\Pr[\textsf{UF}_\textsf{option}(\mathcal{A}) \to 1]$.

For the case when the challenge bit $b = 1$, consider an adversary $\mathcal{A}^\prime$ in Algorithm \ref{alg:adv:ind-uf-OB-Probe} in the $\textsf{RUF}^{ \mathcal{O}^\prime_{\textsf{Enc}} }$ game. $\mathcal{A}^\prime$ runs $\mathcal{A}$ and simulates $\mathcal{O}_{\textsf{Probe}}$ in the following way.

\begin{itemize}

	\item $\mathcal{O}_{\textsf{Probe}}( \textsf{psk}, \mathbf{b}^\prime )$: It first encodes $\mathbf{b}^\prime$ into $\mathbf{y}^\prime$ as before. Next, it computes $d \gets \langle \mathbf{x}^{(*)}, {\mathbf{y}^\prime} \rangle$ and finds a vector $\mathbf{y}^{\prime\prime}$ such that $\langle \mathbf{r}, {\mathbf{y}^{\prime\prime}} \rangle = d$. Finally, it calls $\mathcal{O}^\prime_{\textsf{Enc}} (\mathbf{y}^{\prime\prime} )$ , which is given by the $\textsf{RUF}^{ \mathcal{O}^\prime_{\textsf{Enc}} }$ game, and returns the result.

\end{itemize}

\begin{figure}[h]
\centering
	
	\begin{minipage}[t]{0.85\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$ {\mathcal{A}^\prime}^{ \mathcal{O}^\prime_{\textsf{Enc}} } (\textsf{pp}, \textsf{sk}_{\mathbf{r}}) $}
	\label{alg:adv:ind-uf-OB-Probe}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$ \label{alg:adv:ind-uf-OB-Probe:B}
		
		\State $\mathbf{b}^{(*)} \gets \textsf{getEnroll}^{ \mathcal{O}_{\mathcal{B}} } ()$
		
		\State $\mathbf{x}^{(*)} \gets (b_1^{(*)}, \cdots, b_k^{(*)}, 1, \|\mathbf{b}^{(*)}\|^2)$

		\State Sample $k+2$ linearly independent vectors $\{ \mathbf{e}^{(i)} \}_{i=1}^{k+2}$.

		\For{$i=1$ to $k+2$}
			\State $\textsf{ct}^{(i)} \gets \mathcal{O}^\prime_{\textsf{Enc}}(\mathbf{e}^{(i)})$.

			\State $d_i \gets \textsf{FE.Dec}(\textsf{pp}, \textsf{sk}_{\mathbf{r}}, \textsf{ct}^{(i)})$. \label{alg:adv:ind-uf-OB-Probe:Dec}
		\EndFor

		\State Find the vector $\mathbf{r}$ by solving the linear system $\{ \langle \mathbf{r}, {\mathbf{e}^{(i)}} \rangle = d_i \}_{i=1}^{k+2}$.\label{alg:adv:ind-uf-OB-Probe:r}

		\If{$\mathbf{r} = \mathbf{0}$}

			\State \Return $\bot$

		\EndIf

		\State ${\mathbf{\tilde{z}}} \gets \mathcal{A}^{\mathcal{O}_{\mathcal{B}}, \mathcal{O}_{\textsf{Probe}} } (\textsf{pp}, \textsf{sk}_{\mathbf{r}})$
		
		\State \Return ${\mathbf{\tilde{z}}}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\end{figure}

To make $\mathcal{R}$ simulate $\mathcal{A}^\prime$ in the $\textsf{RUF}^{ \mathcal{O}^\prime_{\textsf{Enc}} }$ game, we still need to ensure two conditions.

\begin{itemize}

	\item $\mathbf{r} \neq \mathbf{0}$. Otherwise, $\mathcal{A}^\prime$ cannot simulate $\mathcal{O}_\textsf{Probe}$. 

	\item $\mathbf{\tilde{z}} \neq \textsf{ct}^{(i)}$ for all $i$. The answers of $\mathcal{O}_\textsf{Probe}$ have already been checked in $\mathcal{R}$. 
\end{itemize}

Let $\mathcal{A}^\prime$ play a tweaked $\textsf{RUF}_\textsf{FE}^{\mathcal{O}^\prime_{\textsf{Enc}}}$ game which does not check that $\mathbf{\tilde{z}}$ is not equal to $\mathbf{c}^{(i)}$ for all $i$. That is, the game only checks whether $\mathbf{\tilde{z}}$ is not equal to any output of $\mathcal{O}^\prime_\textsf{Enc}$ called by $\mathcal{O}_\textsf{Probe}$ of $\mathcal{A}$. Let the returned value of this game be $V$. We have Equation \ref{equ:ind-uf-OB-Probe:1} and \ref{equ:ind-uf-OB-Probe:2}. The former one is a relation between $\mathcal{R}$ playing $\textsf{fh-IND}$ game when the challenge bit $b=1$ and $V$, and the latter is a relation between $\mathcal{A}^\prime$ playing a regular $\textsf{RUF}_\textsf{FE}^{\mathcal{O}^\prime_{\textsf{Enc}}}$ game and the tweaked one.

\begin{gather}
	\Pr[\textsf{Verify}(s) = 1 \mid b = 1 \wedge \mathbf{r} \neq \mathbf{0}] = \Pr[V = 1] \label{equ:ind-uf-OB-Probe:1} \\
	\Pr[\textsf{RUF}_\textsf{FE}^{\mathcal{O}^\prime_{\textsf{Enc}}}(\mathcal{A}^\prime) \to 1] = \Pr\left[ V = 1 \mid \bigwedge_{i=1}^{k+2} \mathbf{\tilde{z}} \neq \textsf{ct}^{(i)} \right] \label{equ:ind-uf-OB-Probe:2}
\end{gather}

\noindent For Equation \ref{equ:ind-uf-OB-Probe:1}, consider that

\begin{align*}
	\Pr[\textsf{Verify}(s) = 1 \mid b = 1]
	&= \Pr[\textsf{Verify}(s) = 1 \mid b = 1 \wedge \mathbf{r} \neq \mathbf{0}] \cdot \Pr[\mathbf{r} \neq \mathbf{0}] \\
	&+ \Pr[\textsf{Verify}(s) = 1 \mid b = 1 \wedge \mathbf{r} = \mathbf{0}] \cdot \Pr[\mathbf{r} = \mathbf{0}] \\
	&\leq \Pr[V = 1] + \Pr[\mathbf{r} = 0] \\
	&= \Pr[V = 1] + \frac{1}{q^{k+2}} 
\end{align*}

\noindent For Equation \ref{equ:ind-uf-OB-Probe:2}, consider that

\begin{align*}
	\Pr[\textsf{RUF}_\textsf{FE}^{\mathcal{O}^\prime_{\textsf{Enc}}}(\mathcal{A}^\prime) \to 1] 
	&= \Pr\left[ V = 1 \mid \bigwedge_{i=1}^{k+2} \mathbf{\tilde{z}} \neq \textsf{ct}^{(i)} \right] \\ 
	& \geq \Pr[V = 1] - \Pr \left[ \neg  \left( \bigwedge_{i=1}^{k+2} \mathbf{\tilde{z}} \neq \textsf{ct}^{(i)} \right) \right] \\
	& = \Pr[V = 1] - \Pr \left[ \bigvee_{i=1}^{k+2} \mathbf{\tilde{z}} = \textsf{ct}^{(i)} \right] \\
	& \geq \Pr[V = 1] - \sum_{i=1}^{k+2} \Pr[\mathbf{\tilde{z}} = \textsf{ct}^{(i)}].
\end{align*}

\noindent Note that each $\textsf{ct}^{(i)}$ is an encryption of of some uniform non-zero vector $\mathbf{e}^{(i)}$. Also note that distinct vectors in $\Z_q^{k+2}$ will have different encryptions due to the correctness of $\textsf{FE}$. Therefore, $\Pr[\mathbf{\tilde{z}} = \textsf{ct}^{(i)}] \leq \frac{1}{q^{k+2} - 1}$ and
\[
	\Pr[\textsf{RUF}_\textsf{FE}^{\mathcal{O}^\prime_{\textsf{Enc}}}(\mathcal{A}^\prime) \to 1] \geq \Pr[V = 1] - \frac{k+2}{q^{k+2}-1}.
\]

\noindent Combining both results from Equation \ref{equ:ind-uf-OB-Probe:1} and \ref{equ:ind-uf-OB-Probe:2}, we derive
\[
	\Pr[\textsf{Verify}(s) = 1 \mid b = 1] \leq \Pr[V = 1] + \frac{1}{q^{k+2}} \leq \Pr[\textsf{RUF}_\textsf{FE}^{\mathcal{O}^\prime_{\textsf{Enc}}}(\mathcal{A}^\prime) \to 1] + \frac{k+2}{q^{k+2}-1} + \frac{1}{q^{k+2}}.
\]

Finally, similar to the proof of Theorem \ref{thm:fh-IPFE:ind-ruf-OB-Enroll}, we derive
\begin{align*}
	\Pr[\textsf{fh-IND}(\mathcal{R}) \to 1]
	&= \frac{1}{2} + \frac{1}{4} \left( \Pr[\textsf{Verify}(s) = 1 \mid b = 0] - \Pr[\textsf{Verify}(s) = 1 \mid b = 1] \right) \\
	&\geq \frac{1}{2} + \frac{1}{4} \left( \Pr[\textsf{UF}_\textsf{option}(\mathcal{A}) \to 1] - \Pr[\textsf{RUF}_\textsf{FE}^{\mathcal{O}^\prime_{\textsf{Enc}}}(\mathcal{A}^\prime) \to 1] - \frac{k+2}{q^{k+2}-1} - \frac{1}{q^{k+2}} \right).
\end{align*}

\noindent Since both $\Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} = \left| \Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] - \frac{1}{2} \right|$ and $\Adv_{\textsf{FE}, \mathcal{A}^\prime}^{\textsf{RUF}, \mathcal{O}^\prime_{\textsf{Enc}}} = \Pr[\textsf{RUF}^{\mathcal{O}^\prime_{\textsf{Enc}}}_{\textsf{FE}}(\mathcal{A}^\prime) \to 1 ]$ are negligible,
\[
	\Pr[\textsf{UF}_\textsf{option}(\mathcal{A}) \to 1] \leq 4 \cdot \Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} + \Adv_{\textsf{FE}, \mathcal{A}^\prime}^{\textsf{RUF}, \mathcal{O}^\prime_{\textsf{Enc}}} + \frac{k+2}{q^{k+2}-1} + \frac{1}{q^{k+2}} = \negl.
\]

\end{proof}

Unfortunately, for the instantiation in Section \ref{sec:fh-IPFE-instantiation}, we cannot achieve UF security when the adversary has \textsf{psk}, even if the false positive rate is negligible. The adversary can simply compute $\mathbf{c} \gets \textsf{Probe}(\textsf{psk}, \mathbf{0})$ and return $\mathbf{c}$. The same results also hold for an $\textsf{option}$ that includes $\textsf{esk}$ since both $\textsf{psk}$ and $\textsf{esk}$ are equal to $\textsf{msk}$ and allow the adversary to run $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{v})$ for any vector $\mathbf{v}$. We state this result formally in the following theorem.

\begin{theorem}

Let $\textsf{option}$ include $\textsf{esk}$ or $\textsf{psk}$. For any distribution family $\mathbb{B}$ and functional encryption $\textsf{FE}$, $\Pi$ is not \textsf{option}-UF secure.

\end{theorem}



\subsection{UF security with \cite{cryptoeprint:2016/440}}

In this section, we show that we can achieve a concrete UF secure scheme by the fh-IPFE scheme given in \cite{cryptoeprint:2016/440}. In a high-level overview, two main reasons make the scheme not UF secure:
\begin{itemize}
	\item The construction \cite{cryptoeprint:2016/440} allows anyone to generate a ciphertext that corresponds to a zero vector, which is described in Theorem \ref{thm:fh-IPFE-not-uf}. This makes the fh-IPFE scheme not even $\emptyset$-RUF secure.

	\item With the master secret key $\mathsf{msk}$, one can reconstruct the vector $\mathbf{x}$ that a secret key $\mathsf{sk}_{\mathbf{x}}$ corresponds to or even submit an encryption $\mathsf{ct}_{\mathbf{y}}$ of a small vector $\mathbf{y}$. This is a drawback of all the schemes instantiated by fh-IPFE in the way described in Section \ref{sec:fh-IPFE-instantiation}. Therefore, we need to instantiate the authentication scheme using a different way.

	[I haven't found a solution for this problem yet, but I am now trying a few possible ways.]
\end{itemize}

We first upgrade the scheme in \cite{cryptoeprint:2016/440}, which is not $\emptyset$-RUF secure due to Theorem \ref{thm:fh-IPFE-not-uf}, to $\mathcal{O}_{\mathsf{KeyGen}}^\prime$-RUF secure. Firstly, for an fh-IPFE scheme $\mathsf{FE}$ over the field $\Z_q$, consider the following transformation $\mathsf{FE}^\prime$:

\begin{itemize}
	\item $\mathsf{FE}^\prime.\mathsf{Setup}$: The same as $\mathsf{FE.Setup}$.

	\item $\mathsf{FE}^\prime.\mathsf{KeyGen}(\mathsf{pp}, \mathsf{msk}, \mathbf{x})$: Sample $\sigma \getsdollar \Z_q$. Return $\mathsf{sk}_{\mathbf{x} \| \sigma} \gets \mathsf{FE.KeyGen}(\mathsf{msk}, \mathsf{pp}, (\mathbf{x} \| \sigma))$ and $\sigma$, where $\mathbf{x} \| \sigma$ is appending $\sigma$ to $\mathbf{x}$.
	
	\item $\mathsf{FE}^\prime.\mathsf{Enc}(\mathsf{pp}, \mathsf{msk}, \mathbf{y})$: Return $\mathsf{ct}_{\mathbf{y} \| 1} \gets \mathsf{FE.Enc}(\mathsf{msk}, \mathsf{pp}, (\mathbf{y} \| 1))$, where $\mathbf{y} \| 1$ is appending the constant $1$ to $\mathbf{y}$.

	\item $\mathsf{FE}^\prime.\mathsf{Dec}(\mathsf{pp}, \mathsf{sk}_{\mathbf{x} \| \sigma}, \sigma, \mathbf{ct}_{\mathbf{y}\| 1})$: Return $\mathsf{FE.Dec}(\mathsf{pp}, \mathsf{sk}_{\mathbf{x}\|\sigma}, \mathbf{c}_{\mathbf{y} \| 1}) - \sigma \bmod q$.

\end{itemize}

\noindent One can show that if $\mathsf{FE}$ is fh-IND secure, $\mathsf{FE}^\prime$ is also fh-IND secure. Moreover, for the concrete construction \cite{cryptoeprint:2016/440}, we prove that $\mathsf{FE}^\prime$ is also $\mathcal{O}_{\mathsf{KeyGen}}^\prime$-RUF secure.

\begin{theorem}
\label{thm:fh-IPFE:2016440-OKeyGen-RUF}
Let $\mathsf{FE}$ be the scheme described in \cite{cryptoeprint:2016/440}. If $\textsf{FE}$ is fh-IND secure, then $\mathsf{FE}^\prime$ is $\mathcal{O}_{\mathsf{KeyGen}}^\prime$-RUF secure.
\end{theorem}

Recall that $\mathsf{FE}$ is proven fh-IND secure in the generic group model. In addition, the decryption of $\mathsf{FE}$ requires speciflying a polynomially-bounded set $S$. It searches $s \in S$ such that $D_1^s = D_2$, where $D_1$ and $D_2$ are elements in a group $\mathbb{G}_T$ of order $q$ that is in exponential of $\lambda$. If no such $s$ is found, the decryption returns $\bot$.

\begin{proof}

Given an adversary $\mathcal{A}$ in the $\textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}}_{\mathsf{FE}^\prime}$ game, consider the reduction adversary $\mathcal{R}$ in Algorithm \ref{alg:red:2016440-OKeyGen-RUF} which plays the \textsf{fh-IND} game of the scheme $\mathsf{FE}$. $\mathcal{R}$ simulates $\mathcal{O}_\textsf{KeyGen}^\prime(\mathbf{x}^\prime)$ by sampling $\sigma \getsdollar \Z_q$ and querying $\mathcal{O}_{\textsf{KeyGen}}(\mathbf{x}^\prime \| \sigma, \mathbf{x}^\prime \| \sigma)$.

\begin{figure}[htp]
\centering
	
	\begin{minipage}[t]{0.5\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\mathcal{R}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}}(\textsf{pp})$}
	\label{alg:red:2016440-OKeyGen-RUF}
	\begin{algorithmic}[1]
		\State $\mathbf{r}^{(0)}, \mathbf{r}^{(1)} \getsdollar \Z_q^k$

		\State $\sigma \getsdollar \Z_q$
		
		\State $\textsf{sk} \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{r}^{(0)} \| \sigma, \mathbf{r}^{(1)} \sigma)$ 

		\State ${\mathbf{\tilde{z}}} \gets {\mathcal{A}}^{\mathcal{O}^\prime_{\textsf{KeyGen}}} (\textsf{pp}, \textsf{sk}, \sigma)$

		\State $\mathbf{r}^\prime \getsdollar \Z_q^{k+1}$

		\State $\textsf{sk}^\prime \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{r}^{(0)} \| \sigma, \mathbf{r}^\prime)$

		\State $s^\prime \gets \textsf{FE.Dec}( \textsf{pp}, \textsf{sk}^\prime, \mathbf{\tilde{z}} ) - \sigma \bmod q$ \label{alg:red:2016440-OKeyGen-RUF:s}

		\State \Return $1_{s^\prime = \bot}$ \label{alg:red:2016440-OKeyGen-RUF:verify}
	
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\end{figure}

In Algorithm \ref{alg:red:2016440-OKeyGen-RUF}, let
\begin{itemize}
	\item $\mathsf{sk} = (g_1^{\alpha_0}, g_1^{\alpha_1}, \cdots, g_1^{\alpha_{k+1}})$.

	\item $\mathsf{sk}^\prime = (g_1^{\alpha_0^\prime}, g_1^{\alpha_1^\prime}, \cdots, g_1^{\alpha_{k+1}^\prime})$.

	\item $s = \mathsf{FE}^\prime.\mathsf{Dec}(\mathsf{pp}, \mathsf{sk}, \mathbf{\tilde{z}}) = \mathsf{FE.Dec}(\mathsf{pp}, \mathsf{sk}, \mathbf{\tilde{z}}) - \sigma \bmod q$.

\end{itemize}

Since $\mathcal{R}$ simulates a $\textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}}_{\mathsf{FE}^\prime}$ game for $\mathcal{A}$, regardless of the challenge bit, we have 
\[
	\Pr[s \neq S] = \Pr[s \in S] = \Pr[ \mathsf{RUF}^{\mathcal{O}^\prime_{\mathsf{KeyGen}}}_{\mathsf{FE}^\prime}(\mathcal{A}) \to 1]
\]
Moreover, if $s \neq \bot$, let $\mathbf{\tilde{z}} = (g_2^{\beta_0}, g_2^{\beta_1}, \cdots g_2^{\beta_{k+1}})$, we have
\[
	\prod_{i=1}^{k+1} e(g_1^{\alpha_i}, g_2^{\beta_i}) = g_T^{\sum_{i=1}^{k+1} \alpha_i \beta_i}
	\implies \mathsf{FE.Dec}(\mathsf{pp}, \mathsf{sk}, \mathbf{\tilde{z}}) = \begin{cases} 
		\frac{\sum_{i=1}^{k+1} \alpha_i \beta_i}{\alpha_0 \beta_0} & \text{if } \beta_0 \neq 0 \\
		0 & \text{if } \beta_0 = 0 \\
	\end{cases}
\]
Similarly, $\mathsf{FE.Dec}(\mathsf{pp}, \mathsf{sk}^\prime, \mathbf{\tilde{z}}) = \frac{\sum_{i=1}^{k+1} \alpha_i^\prime \beta_i}{\alpha_0^\prime \beta_0}$ or $0$. If the challenge bit $b = 0$, since $\mathsf{sk}$ and $\mathsf{sk}^\prime$ correspond to the same vector $\mathbf{r}^{(0)} \| \sigma$, we have 
\[
	\frac{\alpha_0^\prime}{\alpha_0} = \frac{\alpha_1^\prime}{\alpha_1} = \cdots = \frac{\alpha_{k+1}^\prime}{\alpha_{k+1}},
\]
which implies $\mathsf{FE.Dec}(\mathsf{pp}, \mathsf{sk}, \mathbf{\tilde{z}}) = \mathsf{FE.Dec}(\mathsf{pp}, \mathsf{sk}^\prime, \mathbf{\tilde{z}})$ and $s = s^\prime$.

Now, we analyze the advantage of $\mathcal{R}$. If the challenge bit $b = 0$, the probability that $s \neq \bot$ is
\begin{align*}
	\Pr[s^\prime \neq \bot \mid b = 0] 
	&\geq \Pr[s^\prime \in S \mid s \in S, b = 0] \cdot \Pr[s \in S \mid b = 0] \\
	&= 1 \cdot \Pr[ \mathsf{RUF}^{\mathcal{O}^\prime_{\mathsf{KeyGen}}}_{\mathsf{FE}^\prime}(\mathcal{A}) \to 1] 
\end{align*}
If the challenge bit $b = 1$,
\begin{align*}
	\Pr[s^\prime \neq \bot \mid b = 1] 
	&\leq \Pr[s^\prime \in S \mid s \in S, b = 1] + \Pr[s \notin S \mid b = 1] \\
	&\leq \Pr[\mathsf{FE.Dec}(\mathsf{pp}, \mathsf{sk}^\prime, \mathbf{\tilde{z}}) - \sigma \bmod q \in S \mid s \in S, b = 1] \\
	&\quad +  1 - \Pr[\mathsf{RUF}^{\mathcal{O}^\prime_{\mathsf{KeyGen}}}_{\mathsf{FE}^\prime}(\mathcal{A}) \to 1] \\
\end{align*}
Note that $\mathbf{r}^\prime, \mathsf{sk}^\prime$ and thus all $\alpha^\prime_i$ are independent of $\mathbf{\tilde{z}}$ and all $\beta_i$. Hence,
\begin{align*}
	& \Pr[\mathsf{FE.Dec}(\mathsf{pp}, \mathsf{sk}^\prime, \mathbf{\tilde{z}}) - \sigma \bmod q \in S \mid s \in S, b = 1] \\
	& \leq \Pr \left[ \frac{\sum_{i=1}^{k+1} \alpha_i^\prime \beta_i}{\alpha_0^\prime \beta_0} - \sigma \bmod q \in S \mid s \in S, b = 1, \beta_0 \neq 0 \right] + \Pr \left[0 - \sigma \bmod q \in S \right] \\
	& \leq \Pr \left[ \frac{\sum_{i=1}^{k+1} \alpha_i^\prime \beta_i}{\alpha_0^\prime \beta_0} - \sigma \bmod q \in S \mid s \in S, b = 1, \beta_0 \neq 0 \right] + \Pr \left[0 - \sigma \bmod q \in S \right] \\
	& \leq  \frac{|S|}{q} + \frac{|S|}{q} \\
\end{align*}

In conclusion,
\begin{align*}
	\Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] 
	&= \frac{1}{2} \cdot \Pr[s^\prime \neq \bot \mid b = 0] + \frac{1}{2} \cdot \Pr[s^\prime = \bot \mid b = 1] \\
	&\geq \frac{1}{2} \cdot \Pr[ \mathsf{RUF}^{\mathcal{O}^\prime_{\mathsf{KeyGen}}}_{\mathsf{FE}^\prime}(\mathcal{A}) \to 1] + \frac{1}{2} \cdot \left( 1 - \frac{2|S|}{q} - (1 - \Pr[\mathsf{RUF}^{\mathcal{O}^\prime_{\mathsf{KeyGen}}}_{\mathsf{FE}^\prime}(\mathcal{A}) \to 1]) \right) \\
	&= \frac{1}{2} \cdot \Pr[ \mathsf{RUF}^{\mathcal{O}^\prime_{\mathsf{KeyGen}}}_{\mathsf{FE}^\prime}(\mathcal{A}) \to 1] - \frac{|S|}{q} + \frac{1}{2} \cdot \Pr[\mathsf{RUF}^{\mathcal{O}^\prime_{\mathsf{KeyGen}}}_{\mathsf{FE}^\prime}(\mathcal{A}) \to 1]) \\
	&= \Pr[ \mathsf{RUF}^{\mathcal{O}^\prime_{\mathsf{KeyGen}}}_{\mathsf{FE}^\prime}(\mathcal{A}) \to 1] - \frac{|S|}{q}
\end{align*}

\noindent Since $\Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} = \left| \Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] - \frac{1}{2} \right|$ and $\frac{|S|}{q}$ are negligible,
\[
	\Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1]  \leq \frac{|S|}{q} + \Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} = \negl.
\]

\end{proof}

To instantiate the authentication scheme $\Pi$ using the way described in Section \ref{sec:fh-IPFE-instantiation} with $\mathsf{FE}^\prime$, we assume that $s \in S$ for all integer $s \leq \tau^2$, the pre-defined threshold in the biometric layer. Along with Theorem \ref{thm:fh-IPFE:ind-ruf-OB-Enroll}, we have the following result.

\begin{corollary}
\label{cor:fh-IPFE:2016440-OB-Enroll}

Let $\textsf{option} = \{ \textsf{csk}, \mathbf{c_x}, \mathcal{O}_\mathcal{B}, \mathcal{O}_{\textsf{Enroll}} \}$, and let $\mathsf{FE}$ be the scheme described in \cite{cryptoeprint:2016/440}. If $\mathsf{FE}$ is fh-IND secyre, then for any distribution family $\mathbb{B}$, the authentication scheme instantiated by $\mathsf{FE}^\prime$ is $\textsf{option}$-UF secure.

\end{corollary}


%-------------------


\subsection{IND Security of $\Pi$}
\label{sec:security_analysis:fh-IPFE:IND}

For the IND security, we first consider the following definition and assumption on the biometric distribution family $\mathbb{B}$.

\begin{definition}
For an authentication scheme $\Pi$, a distribution $\mathcal{B} \in \mathbb{B}$, and an integer $t$, define the distribution $\mathcal{D}_\mathcal{B}(t)$ as
\[
	\mathcal{D}_\mathcal{B}(t) = \left( \textsf{BioCompare}(\mathbf{b}, \mathbf{b}^{(1)}), \textsf{BioCompare}(\mathbf{b}, \mathbf{b}^{(2)}), \cdots, \textsf{BioCompare}(\mathbf{b}, \mathbf{b}^{(t)}) \right)
\]
where $\mathbf{b} \gets \textsf{getEnroll}^{\mathcal{O}_\mathcal{B}}()$ and $ \mathbf{b}^{(i)} \gets \textsf{getProbe}^{\mathcal{O}_\mathcal{B}}()$ for all $i \in [t]$.

\end{definition}

\begin{assumption}
\label{assump:equal_distance}
Let $t$ be an integer. Assume that for any two distributions $\mathcal{B}^{(0)}$ and $\mathcal{B}^{(1)}$ in the biometric distribution family $\mathbb{B}$, $\mathcal{D}_{ \mathcal{B}^{(0)} }(t)$ and $\mathcal{D}_{ \mathcal{B}^{(1)} }(t)$ are the same. 

\end{assumption}

Note that indistinguishability between $\mathcal{D}_{ \mathcal{B}^{(0)} }(t)$ and $\mathcal{D}_{ \mathcal{B}^{(1)} }(t)$ is a necessary condition to achieve \textsf{option}-IND security when $\textsf{option}$ includes $\textsf{csk}, \mathbf{c_x}$ and $\mathcal{O}_{\mathbf{c_y}}$ because
\[
	\left( \textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{c_y}^{(1)}), \cdots, \textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{c_y}^{(t)}) \right) = \mathcal{D}_{ \mathcal{B}^{(b)} }(t)
\]
where $b$ is the challenge bit.


\begin{theorem}
\label{thm:fh-IPFE:ind-ind}
Let $\textsf{option} = \{ \textsf{csk}, \mathbf{c_x},  \mathcal{O}_{\mathbf{c_y}} \}.$ For a distribution family $\mathbb{B}$ satisfying Assumption \ref{assump:equal_distance} and having a true positive rate $\textsf{TP} > \frac{1}{\poly}$, if \textsf{FE} is fh-IND secure, then $\Pi$ is \textsf{option}-IND secure.

\end{theorem}



\begin{proof}

Given an adversary $\mathcal{A}$ in the $\textsf{IND}_{\textsf{option}}$ game, consider the reduction adversary $\mathcal{R}$ in Algorithm \ref{alg:red:ind-ind} which plays the \textsf{fh-IND} game by running $\mathcal{A}$. $\mathcal{R}$ simulates $\mathcal{O}_{\mathbf{c_y}}$ by the following steps.

\begin{enumerate}

	\item Sample ${\mathbf{b}^\prime}^{(0)} \gets \textsf{getProbe}^{\mathcal{O}_{\mathcal{B}^{(0)}}}()$ and let $\mathbf{y}^{(0)} \gets (-2{b_1^\prime}^{(0)}, \cdots, -2{b_k^\prime}^{(0)}, \| {\mathbf{b}^\prime}^{(0)} \|^2, 1) $

	\item Repeat sampling ${\mathbf{b}^\prime}^{(1)} \gets \textsf{getProbe}^{\mathcal{O}_{\mathcal{B}^{(1)}}}()$ and let $\mathbf{y}^{(1)} \gets (-2{b_1^\prime}^{(1)}, \cdots, -2{b_k^\prime}^{(1)}, \| {\mathbf{b}^\prime}^{(1)} \|^2, 1)$ until $\langle \mathbf{x}^{(0)}, {\mathbf{y}^{(0)}} \rangle = \langle \mathbf{x}^{(1)}, {\mathbf{y}^{(1)}} \rangle$.
	
	\item Return $\textsf{ct}_{\mathbf{y}}^{(i)} \gets \mathcal{O}_{\textsf{Enc}}(\mathbf{y}^{(0)}, \mathbf{y}^{(1)})$.

\end{enumerate}

\begin{figure}[h]
\centering
	
	\begin{minipage}[t]{0.75\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\mathcal{R}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}}(\textsf{pp})$}
	\label{alg:red:ind-ind}
	\begin{algorithmic}[1]
		\State $\mathcal{B}^{(0)} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}^{(0)}$ \label{alg:red:ind-ind:B0}
		
		\State $\mathcal{B}^{(1)} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}^{(1)}$ \label{alg:red:ind-ind:B1}

		\State $\mathbf{b}^{(0)} \gets \textsf{getEnroll}^{\mathcal{O}_{\mathcal{B}^{(0)}}}(), \mathbf{x}^{(0)} \gets (b_1^{(0)}, \cdots, b_k^{(0)}, 1, \|\mathbf{b}^{(0)}\|^2)$
		
		\State $\mathbf{b}^{(1)} \gets \textsf{getEnroll}^{\mathcal{O}_{\mathcal{B}^{(1)}}}(), \mathbf{x}^{(1)} \gets (b_1^{(1)}, \cdots, b_k^{(1)}, 1, \|\mathbf{b}^{(1)}\|^2)$
		
		\State $\textsf{sk} \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{x}^{(0)}, \mathbf{x}^{(1)})$ \label{alg:red:ind-ind:cx}

		\State $\tilde{b} \gets {\mathcal{A}}^{\mathcal{O}_{\mathcal{B}^{(0)}}, \mathcal{O}_{\mathcal{B}^{(1)}}, \mathcal{O}_{\mathbf{c_y}} } (\textsf{pp}, \textsf{sk})$ \label{alg:red:ind-ind:A}

		\State \Return $\tilde{b}$

	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\end{figure}

\noindent Note that $(\mathbf{x}^{(0)}, \mathbf{x}^{(1)})$ is the only query of $\mathcal{R}$ to $\mathcal{O}_{\textsf{KeyGen}}$, and for any query $( \mathbf{y}^{(0)}, {\mathbf{y}^{(1)}} )$ to $\mathcal{O}_{\textsf{Enc}}$, it satisfies $\langle \mathbf{x}^{(0)}, {\mathbf{y}^{(0)}} \rangle = \langle \mathbf{x}^{(1)}, {\mathbf{y}^{(1)}} \rangle$. Hence, $\mathcal{R}$ is an admissible adversary.

We first show that the simulation of oracle $\mathcal{O}_{\mathbf{c_y}}$ is efficient. The probability that $\langle \mathbf{x}^{(0)}, {\mathbf{y}^{(0)}} \rangle = \langle \mathbf{x}^{(1)}, {\mathbf{y}^{(1)}} \rangle$ is satisfied is
\begin{align*}
	\Pr[\mathcal{D}_{\mathcal{B}^{(0)}}(1) = \mathcal{D}_{\mathcal{B}^{(1)}}(1)] 
	&\geq \sum_{i=0}^\tau \Pr[\mathcal{D}_{\mathcal{B}^{(0)}}(1) = i]^2 \qquad \text{(Assumption \ref{assump:equal_distance})} \\
	&\geq \frac{1}{\tau + 1} \cdot \left( \sum_{i=0}^\tau \Pr[\mathcal{D}_{\mathcal{B}^{(0)}}(1) = i] \right)^2 \\
	&= \frac{1}{\tau + 1} \cdot \left( \Pr \left[
		\begin{aligned}
			& \mathbf{b} \gets \textsf{getEnroll}^{\mathcal{O}_{\mathcal{B}^{(0)}} }() \\
			& \mathbf{b}^\prime \gets \textsf{getProbe}^{\mathcal{O}_{\mathcal{B}^{(0)}} }()
		\end{aligned}
		: \| \mathbf{b} - \mathbf{b}^\prime \| \leq \tau \right] \right)^2 \\
	&= \frac{ \textsf{TP}(\mathcal{B}^{(0)})^2 }{\tau + 1} = \frac{ \textsf{TP}^2 }{\tau + 1} \qquad \text{(Assumption \ref{assump:equal_distance})} 
\end{align*}
The expected number of repetitions is bounded above by $\frac{\tau + 1}{ \textsf{TP}^2 }$. Moreover, the probability that it is satisfied within $T$ repetitions is at least
\[
	1 - (1 - \frac{ \textsf{TP}^2 }{\tau + 1})^T \geq 1 - e^{-T \cdot \frac{ \textsf{TP}^2 }{\tau + 1}}
\]
We can reach a $1 - \negl.$ probability that the loop will end within $T$ times by setting a polynomial-size $T$.

Now, we show that $\mathcal{R}$ perfectly simulate an $\textsf{IND}_{\textsf{option}}$ game for $\mathcal{A}$. Assume that $\mathcal{A}$ makes $t$ queries to $\mathcal{O}_{\mathbf{c_y}}$ and receives probe messages $\{ \mathbf{c_y}^{(i)} \}_{i=1}^t = \{ \textsf{ct}_{\mathbf{y}}^{(i)} \}_{i=1}^t$. If the challenge bit $b$ of the \textsf{fh-IND} game is $0$, $\mathbf{c_x} = \textsf{sk}$ and $\mathbf{c_y}^{(i)}$ for all $i \in [t]$ are generated from $\mathcal{B}^{(0)}$ and have the same distributions as the inputs for an adversary in \textsf{IND} game.
If the challenge bit $b$ is $1$, we show that distributions of $\mathbf{c_x}, \{ \mathbf{c_y}^{(i)} \}_{i=1}^t$ also follow the same distribution given Assumption \ref{assump:equal_distance}.

Let $b^\prime \in \{0, 1\}$, define distributions 
\begin{align*}
	\mathbf{X}^{(b^\prime)} &= \{ \mathbf{b}^{(b^\prime)} \gets \textsf{getEnroll}^{\mathcal{O}_{\mathcal{B}^{(b^\prime)}}}() : \mathbf{x}^{(b^{\prime})} \gets (b_1^{(b^{\prime})}, \cdots, b_k^{(b^{\prime})}, 1, \|\mathbf{b}^{ (b^{\prime}) }\|^2) \} \\
	\mathbf{Y}^{ (b^\prime) }_i &= \{ \mathbf{b}^{(b^\prime)} \gets \textsf{getProbe}^{\mathcal{O}_{\mathcal{B}^{(b^\prime)}}}() : \mathbf{y}^{(b^{\prime})} \gets ( -2b_1^{(b^{\prime})}, \cdots, -2b_k^{(b^{\prime})}, \|\mathbf{b}^{ (b^{\prime}) }\|^2, 1) \} \\
	\{ \mathbf{Y}^{ (b^\prime) }_i \}_{i=1}^t &= (\mathbf{Y}^{ (b^\prime) }_1, \cdots, \mathbf{Y}^{ (b^\prime) }_t) \quad  \text{ ($t$ identical and independent distributions) }
\end{align*}

\noindent Note that for any $\{ d_i \}_{i=1}^t, d_i > 0$,
\begin{align*}
\Pr \left[ \bigwedge_{i=1}^t \left\langle \mathbf{X}^{(0)}, {\mathbf{Y}^{(0)}_i} \right\rangle = d_i^2 \right] 
&= \Pr \left[ \mathcal{D}_{\mathcal{B}^{(0)}}(t) = (d_1, \cdots, d_t) \right] \\
&= \Pr \left[ \mathcal{D}_{\mathcal{B}^{(1)}}(t) = (d_1, \cdots, d_t) \right] = \Pr \left[ \bigwedge_{i=1}^t \left\langle \mathbf{X}^{(1)}, {\mathbf{Y}^{(1)}_i} \right\rangle = d_i^2 \right]
\end{align*}

Now, let $\mathbf{Y}^\prime_i$ be the distribution of $\mathbf{y}^{(1)}$ derived in the $i$-th query to $\mathcal{O}_{\mathbf{c_y}}$. For any $\mathbf{x}$ and $\{ \mathbf{y}_i \}_{i=1}^t$,
\begin{align*}
	& \Pr [\mathbf{X}^{(1)} = \mathbf{x}, \mathbf{Y}^\prime_1 = \mathbf{y}_1, \cdots, \mathbf{Y}^\prime_t = \mathbf{y}_t] \\
	&= \sum_{d_1, \cdots, d_t} \left( \Pr \left[\mathbf{X}^{(1)} = \mathbf{x}, \mathbf{Y}^{(1)}_1 = \mathbf{y}_1, \cdots, \mathbf{Y}^{(1)}_t = \mathbf{y}_t \mid \bigwedge_{i=1}^t \left\langle \mathbf{X}^{(1)}, {\mathbf{Y}^{(1)}_i} \right\rangle = d_i^2 \right] \right. \\
	&\qquad \qquad \left. \times \Pr \left[\bigwedge_{i=1}^t \left\langle \mathbf{X}^{(0)}, {\mathbf{Y}_i^{(0)}} \right\rangle = d_i^2 \right] \right) \\
	&= \sum_{d_1, \cdots, d_t} \left( \Pr \left[\mathbf{X}^{(1)} = \mathbf{x}, \mathbf{Y}^{(1)}_1 = \mathbf{y}_1, \cdots, \mathbf{Y}^{(1)}_t = \mathbf{y}_t \mid \bigwedge_{i=1}^t \left\langle \mathbf{X}^{(1)}, {\mathbf{Y}^{(1)}_i} \right\rangle = d_i^2 \right] \right. \\
	&\qquad \qquad \left. \times \Pr \left[\bigwedge_{i=1}^t \left\langle \mathbf{X}^{(1)}, {\mathbf{Y}_i^{(1)}} \right\rangle = d_i^2 \right] \right) \\
	&= \Pr[\mathbf{X}^{(1)} = \mathbf{x}, \mathbf{Y}^{(1)}_1 = \mathbf{y}_1, \cdots, \mathbf{Y}^{(1)}_t = \mathbf{y}_t ]
\end{align*}

\noindent which implies $\mathcal{R}$ also perfectly simulate an $\textsf{IND}_{\textsf{option}}$ game for $\mathcal{A}$ when the challenge bit $b = 1$.

In conclusion, 
\[
	\Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} = \Adv_{\Pi, \mathbb{B}, \mathcal{A}, \textsf{option}}^\textsf{IND} = \negl.
\]
which holds for all adversaries $\mathcal{A}$ in the $\textsf{IND}_{\textsf{option}}$ game. This implies the \textsf{option}-IND security of $\Pi$.


\end{proof}

